# Open Notes Multi-Service Project Configuration
# ==============================================
#
# Task Naming Convention: verb:noun:object:environment
#   - build:containers:server     (build container for server)
#   - build:types:openapi         (build OpenAPI types)
#   - test:server                 (run server tests)
#   - lint:discord                (run discord linter)
#   - db:migrate                  (run database migrations)
#   - validate:api                (validate API endpoints)
#
# For specific test/lint options, use -- to pass args:
#   - mise run test:server -- -k test_auth
#   - mise run lint:server -- --fix
#
# See: mise tasks

[tools]
python = "3.11"
uv = "latest"
node = "20"
pnpm = "latest"
yq = "latest"

[env]
IMAGE_TAG = "local"
_.file = ".env.yaml"

[vars]
server_dir = "opennotes-server"
discord_dir = "opennotes-discord"

# ========================================
# Internal Helper Tasks
# ========================================

[tasks."_env:convert"]
description = "Convert .env.yaml files to .env format for docker-compose"
run = '''
# Convert main .env.yaml for docker-compose
if [ -f ".env.yaml" ]; then
    echo "Converting .env.yaml -> .env"
    yq eval -o=shell '.' ".env.yaml" > ".env"
fi

# Convert service-specific .env.yaml files
for yaml_file in opennotes-*/.env.yaml; do
    if [ -f "$yaml_file" ]; then
        env_file="${yaml_file%.yaml}"
        echo "Converting $yaml_file -> $env_file"
        yq eval -o=shell '.' "$yaml_file" > "$env_file"
    fi
done
'''

[tasks."_env:cleanup"]
description = "Remove generated .env files (keep .env.yaml as source of truth)"
run = '''
rm -f .env
find opennotes-* -name ".env" -not -name "*.yaml" -type f -delete
echo "Cleaned up generated .env files"
'''

[tasks."_db:ensure-postgres"]
description = "Internal: Ensure PostgreSQL is available (container or DATABASE_URL)"
run = '''
# If DATABASE_URL is set, validate that the hostname is resolvable
if [ -n "${DATABASE_URL:-}" ]; then
    DB_HOST=$(echo "$DATABASE_URL" | sed -n 's|.*@\([^:]*\):.*|\1|p')
    if [ -n "$DB_HOST" ] && [ "$DB_HOST" != "localhost" ] && [ "$DB_HOST" != "127.0.0.1" ]; then
        if ! ping -c1 -W1 "$DB_HOST" >/dev/null 2>&1; then
            echo "Error: Cannot resolve hostname '$DB_HOST' from DATABASE_URL." >&2
            echo "" >&2
            echo "This typically happens when .env.yaml uses Docker-internal hostnames" >&2
            echo "(e.g., 'postgres') which only resolve inside Docker containers." >&2
            echo "" >&2
            echo "Fix: Update .env.yaml to use 'localhost' instead of '$DB_HOST':" >&2
            echo "    DATABASE_URL=postgresql+asyncpg://...@localhost:5432/..." >&2
            echo "" >&2
            echo "Containers receive their own URLs via OpenTofu env vars," >&2
            echo "so this change only affects host-side tools (mise, alembic, pytest)." >&2
            exit 1
        fi
    fi
    echo "DATABASE_URL is set, using external PostgreSQL." >&2
    exit 0
fi

CONTAINER_NAME="opennotes-postgres"

# Check if container exists
if ! docker ps -a -q -f name="$CONTAINER_NAME" | grep -q .; then
    echo "Error: Container '$CONTAINER_NAME' does not exist." >&2
    echo "" >&2
    echo "The database container is managed by OpenTofu. Please run:" >&2
    echo "    mise run apply:infra:local" >&2
    echo "" >&2
    exit 1
fi

# Check if container is running
if docker ps -q -f name="$CONTAINER_NAME" | grep -q .; then
    exit 0
fi

# Container exists but is not running - prompt user
echo "Container '$CONTAINER_NAME' exists but is not running."
read -p "Start it? [y/N] " -n 1 -r
echo
if [[ ! $REPLY =~ ^[Yy]$ ]]; then
    echo "Aborted." >&2
    exit 1
fi

echo "Starting $CONTAINER_NAME..."
docker start "$CONTAINER_NAME"

# Wait for postgres to be ready
echo "Waiting for PostgreSQL to be ready..."
for i in {1..30}; do
    if docker exec "$CONTAINER_NAME" pg_isready -U opennotes >/dev/null 2>&1; then
        echo "PostgreSQL is ready."
        exit 0
    fi
    sleep 1
done

echo "Error: PostgreSQL did not become ready within 30 seconds." >&2
exit 1
'''

[tasks."_db:get-prefix"]
description = "Internal: Detect environment and output command prefix for database operations"
dir = "{{vars.server_dir}}"
run = '''
# Check if opennotes-server container is running
if docker ps -q -f name=opennotes-server | grep -q .; then
    echo "Running inside opennotes-server container..." >&2
    echo "docker exec opennotes-server "
else
    echo "Running on host..." >&2
    # Check if database is accessible before proceeding
    if [ -z "${DATABASE_URL:-}" ]; then
        echo "DATABASE_URL not set. Cannot run database operations on host." >&2
        echo "   Either:" >&2
        echo "   1. Start containers: mise run dev:up" >&2
        echo "   2. Set DATABASE_URL environment variable" >&2
        exit 1
    fi
    echo ""
fi
'''

# ========================================
# Development Tasks
# ========================================

[tasks.install]
description = "Install project dependencies"
run = [
    "cd {{vars.server_dir}} && uv venv && uv pip install -e '.[dev]'",
    "cd {{vars.discord_dir}} && pnpm install"
]

[tasks.dev]
description = "Start development environment and generate types"
run = '''
# Generate OpenAPI spec and TypeScript types
echo "Generating OpenAPI spec and TypeScript types..."
cd {{vars.server_dir}} && uv run python scripts/generate_openapi.py --output openapi.json
cd ../{{vars.discord_dir}} && pnpm types:generate

echo ""
echo "Development environment ready!"
echo "   Server: http://localhost:8000"
echo "   Discord: http://localhost:3000"
'''

# ========================================
# Testing Tasks
# ========================================

[tasks.test]
description = "Run all tests"
depends = ["test:server", "test:discord"]

[tasks."test:server"]
description = "Run server tests (pass options via --)"
dir = "{{vars.server_dir}}"
run = 'uv run pytest -v "$@"'
sources = ["src/**/*.py", "tests/**/*.py"]
env = { PYTHONPATH = "." }

[tasks."test:discord"]
description = "Run Discord bot tests (pass options via --)"
dir = "{{vars.discord_dir}}"
run = "pnpm test \"$@\""
sources = ["src/**/*.ts", "tests/**/*.ts"]

[tasks."test:schemathesis"]
description = "Run Schemathesis property-based API tests"
dir = "{{vars.server_dir}}"
run = 'uv run pytest tests/schemathesis/ -v "$@"'
env = { PYTHONPATH = ".", RATE_LIMIT_ENABLED = "false" }

# ========================================
# Linting Tasks
# ========================================

[tasks.lint]
description = "Run all linters"
depends = ["lint:server", "lint:discord"]

[tasks."lint:server"]
description = "Run Python linters (use -- --fix to auto-fix)"
dir = "{{vars.server_dir}}"
run = '''
# Check if --fix was passed
if [[ " $* " == *" --fix "* ]]; then
    echo "Fixing Python linting issues..."
    uv run ruff format src tests
    uv run ruff check --fix src tests
else
    uv run ruff format --check src tests
    uv run ruff check src tests
    uv run basedpyright src
fi
'''

[tasks."lint:discord"]
description = "Run TypeScript linters (use -- --fix to auto-fix)"
dir = "{{vars.discord_dir}}"
run = '''
# Check if --fix was passed
if [[ " $* " == *" --fix "* ]]; then
    pnpm run lint:fix
else
    pnpm run lint
fi
'''

# ========================================
# Database Tasks
# ========================================

[tasks."db:migrate"]
description = "Run database migrations (container-aware)"
depends = ["_db:ensure-postgres"]
dir = "{{vars.server_dir}}"
run = '''
DB_OPS_CMD_PREFIX="$(mise run _db:get-prefix)"
${DB_OPS_CMD_PREFIX}uv run alembic upgrade head
'''
alias = "migrate"

[tasks."db:migrate:create"]
description = "Create new migration (container-aware)"
depends = ["_db:ensure-postgres"]
dir = "{{vars.server_dir}}"
run = '''
MESSAGE="{{arg(name="message")}}"
DB_OPS_CMD_PREFIX="$(mise run _db:get-prefix)"
${DB_OPS_CMD_PREFIX}uv run alembic revision --autogenerate -m "$MESSAGE"
'''
usage = '''
arg "message" description="Migration message" default="auto migration"
'''

[tasks."db:migrate:history"]
description = "Show migration history (container-aware)"
depends = ["_db:ensure-postgres"]
dir = "{{vars.server_dir}}"
run = '''
DB_OPS_CMD_PREFIX="$(mise run _db:get-prefix)"
${DB_OPS_CMD_PREFIX}uv run alembic history
'''

[tasks."db:migrate:stamp"]
description = "Force-set alembic_version (for orphaned migration recovery)"
depends = ["_db:ensure-postgres"]
dir = "{{vars.server_dir}}"
run = '''
REVISION="{{arg(name="revision")}}"

echo "WARNING: This command force-sets the alembic_version table."
echo "Use this only when your database points to a non-existent revision"
echo "(e.g., after switching from a feature branch that had migrations)."
echo ""
echo "Target revision: $REVISION"
echo ""
read -p "Are you sure? [y/N] " -n 1 -r
echo
if [[ ! $REPLY =~ ^[Yy]$ ]]; then
    echo "Aborted."
    exit 1
fi

DB_OPS_CMD_PREFIX="$(mise run _db:get-prefix)"
${DB_OPS_CMD_PREFIX}uv run alembic stamp "$REVISION"
echo "Database stamped to revision: $REVISION"
'''
usage = '''
arg "revision" description="Target revision (use 'head' for latest)" default="head"
'''

[tasks."db:shell"]
description = "Open database shell"
depends = ["_db:ensure-postgres"]
run = "docker exec -it opennotes-postgres psql -U opennotes -d opennotes"

[tasks."db:check"]
description = "Check for schema drift between models and database (container-aware)"
depends = ["_db:ensure-postgres"]
dir = "{{vars.server_dir}}"
run = '''
DB_OPS_CMD_PREFIX="$(mise run _db:get-prefix)"
${DB_OPS_CMD_PREFIX}uv run alembic check
'''
alias = "check-schema"

[tasks."redis:cli"]
description = "Open Redis CLI"
run = "docker exec -it opennotes-redis redis-cli"

# ========================================
# Database Branching Tasks
# ========================================

[tasks."_db:branch-name"]
description = "Internal: Get sanitized branch database name from current git branch"
run = '''
BRANCH=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)
if [ -z "$BRANCH" ] || [ "$BRANCH" = "HEAD" ]; then
    echo "Error: Not on a git branch or in detached HEAD state." >&2
    exit 1
fi

# Sanitize: replace non-alphanumeric with underscore, lowercase
SANITIZED=$(echo "$BRANCH" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/_/g' | sed 's/__*/_/g' | sed 's/^_//;s/_$//')

# Prefix with opennotes_
echo "opennotes_${SANITIZED}"
'''

[tasks."db:branch:create"]
description = "Create a branch-specific database cloned from main opennotes database"
depends = ["_db:ensure-postgres"]
run = '''
BRANCH_DB=$(mise run _db:branch-name)
MAIN_DB="opennotes"
CONTAINER="opennotes-postgres"
DB_USER="opennotes"

if [ "$BRANCH_DB" = "opennotes_main" ]; then
    echo "Error: You're on the main branch. No need to create a branch database." >&2
    echo "The main database 'opennotes' is used directly." >&2
    exit 1
fi

echo "Creating branch database: $BRANCH_DB"
echo "Cloning from: $MAIN_DB"
echo ""

# Check if branch database already exists
EXISTS=$(docker exec "$CONTAINER" psql -U "$DB_USER" -d postgres -tAc "SELECT 1 FROM pg_database WHERE datname='$BRANCH_DB'" 2>/dev/null)
if [ "$EXISTS" = "1" ]; then
    echo "Database '$BRANCH_DB' already exists."
    read -p "Drop and recreate? [y/N] " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        echo "Aborted."
        exit 1
    fi
    echo "Dropping existing database..."
    docker exec "$CONTAINER" psql -U "$DB_USER" -d postgres -c "DROP DATABASE \"$BRANCH_DB\";"
fi

# Terminate connections to main database (required for TEMPLATE cloning)
echo "Terminating connections to $MAIN_DB..."
docker exec "$CONTAINER" psql -U "$DB_USER" -d postgres -c "
    SELECT pg_terminate_backend(pid)
    FROM pg_stat_activity
    WHERE datname = '$MAIN_DB' AND pid <> pg_backend_pid();
" >/dev/null 2>&1 || true

# Clone database using TEMPLATE
echo "Cloning database (this may take a moment)..."
docker exec "$CONTAINER" psql -U "$DB_USER" -d postgres -c "CREATE DATABASE \"$BRANCH_DB\" TEMPLATE \"$MAIN_DB\";"

echo ""
echo "✓ Branch database created: $BRANCH_DB"
echo ""
echo "To use this database, run:"
echo "    mise run db:branch:switch"
'''

[tasks."db:branch:switch"]
description = "Switch DATABASE_URL to the branch database (outputs export command)"
depends = ["_db:ensure-postgres"]
run = '''
BRANCH_DB=$(mise run _db:branch-name)
CONTAINER="opennotes-postgres"
DB_USER="opennotes"

# Check if branch database exists
EXISTS=$(docker exec "$CONTAINER" psql -U "$DB_USER" -d postgres -tAc "SELECT 1 FROM pg_database WHERE datname='$BRANCH_DB'" 2>/dev/null)

if [ "$EXISTS" != "1" ]; then
    if [ "$BRANCH_DB" = "opennotes_main" ]; then
        echo "On main branch - using default 'opennotes' database."
        BRANCH_DB="opennotes"
    else
        echo "Error: Branch database '$BRANCH_DB' does not exist." >&2
        echo "Create it first with: mise run db:branch:create" >&2
        exit 1
    fi
fi

# Get current DATABASE_URL components or use defaults
HOST="${POSTGRES_HOST:-localhost}"
PORT="${POSTGRES_PORT:-5432}"
USER="${POSTGRES_USER:-opennotes}"
PASS="${POSTGRES_PASSWORD:-opennotes}"

NEW_URL="postgresql+asyncpg://${USER}:${PASS}@${HOST}:${PORT}/${BRANCH_DB}"

echo "To switch to branch database '$BRANCH_DB', run:"
echo ""
echo "    export DATABASE_URL=\"$NEW_URL\""
echo ""
echo "Or add to your .env file:"
echo "    DATABASE_URL=$NEW_URL"
echo ""
echo "Current branch: $(git rev-parse --abbrev-ref HEAD)"
echo "Target database: $BRANCH_DB"
'''

[tasks."db:branch:delete"]
description = "Delete the branch-specific database"
depends = ["_db:ensure-postgres"]
run = '''
BRANCH_DB=$(mise run _db:branch-name)
CONTAINER="opennotes-postgres"
DB_USER="opennotes"

if [ "$BRANCH_DB" = "opennotes_main" ]; then
    echo "Error: Cannot delete the main database." >&2
    exit 1
fi

# Check if branch database exists
EXISTS=$(docker exec "$CONTAINER" psql -U "$DB_USER" -d postgres -tAc "SELECT 1 FROM pg_database WHERE datname='$BRANCH_DB'" 2>/dev/null)
if [ "$EXISTS" != "1" ]; then
    echo "Database '$BRANCH_DB' does not exist."
    exit 0
fi

echo "This will permanently delete database: $BRANCH_DB"
read -p "Are you sure? [y/N] " -n 1 -r
echo
if [[ ! $REPLY =~ ^[Yy]$ ]]; then
    echo "Aborted."
    exit 1
fi

# Terminate connections
echo "Terminating connections..."
docker exec "$CONTAINER" psql -U "$DB_USER" -d postgres -c "
    SELECT pg_terminate_backend(pid)
    FROM pg_stat_activity
    WHERE datname = '$BRANCH_DB' AND pid <> pg_backend_pid();
" >/dev/null 2>&1 || true

# Drop database
docker exec "$CONTAINER" psql -U "$DB_USER" -d postgres -c "DROP DATABASE \"$BRANCH_DB\";"

echo "✓ Deleted database: $BRANCH_DB"
'''

[tasks."db:branch:list"]
description = "List all branch databases and show which is active"
depends = ["_db:ensure-postgres"]
run = '''
CONTAINER="opennotes-postgres"
DB_USER="opennotes"

# Get current DATABASE_URL database name
if [ -n "${DATABASE_URL:-}" ]; then
    # Extract database name from URL (last path component)
    CURRENT_DB=$(echo "$DATABASE_URL" | sed 's|.*/||')
else
    CURRENT_DB="opennotes"
fi

echo "Branch databases (opennotes_*):"
echo "================================"

# List all opennotes_* databases
docker exec "$CONTAINER" psql -U "$DB_USER" -d postgres -tAc "
    SELECT datname || CASE WHEN datname = '$CURRENT_DB' THEN ' (active)' ELSE '' END
    FROM pg_database
    WHERE datname LIKE 'opennotes_%'
    ORDER BY datname;
"

echo ""
echo "Main database:"
echo "=============="
if [ "$CURRENT_DB" = "opennotes" ]; then
    echo "opennotes (active)"
else
    echo "opennotes"
fi

echo ""
echo "Current branch: $(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo 'N/A')"
echo "Active database: $CURRENT_DB"
'''

# ========================================
# Build Tasks
# ========================================

[tasks."build:deps:server"]
description = "Install server dependencies (skipped if lock files unchanged)"
dir = "{{vars.server_dir}}"
run = "uv sync"
sources = ["pyproject.toml", "uv.lock"]
outputs = [".venv/pyvenv.cfg"]

[tasks."build:deps:discord"]
description = "Install Discord bot dependencies (skipped if lock files unchanged)"
dir = "{{vars.discord_dir}}"
run = "pnpm install"
sources = ["pnpm-lock.yaml"]
outputs = ["node_modules/.modules.yaml"]

[tasks."build:containers:all"]
description = "Build all Docker images"
depends = ["build:containers:server", "build:containers:discord", "build:containers:postgres"]
alias = "build"

[tasks."build:containers:server"]
depends = ["_env:convert", "build:types:openapi", "build:deps:server"]
description = "Build opennotes-server image"
run = "docker build -t opennotes-server:{{env.IMAGE_TAG}} -f {{vars.server_dir}}/Dockerfile ."

[tasks."build:containers:discord"]
depends = ["_env:convert", "build:types:openapi", "build:deps:discord"]
description = "Build opennotes-discord image"
run = "docker build -t opennotes-discord:{{env.IMAGE_TAG}} -f {{vars.discord_dir}}/Dockerfile ."

[tasks."build:containers:postgres"]
description = "Build PostgreSQL image with pgvector, pgroonga, and pg_cron (smart rebuild)"
run = '''
IMAGE_NAME="opennotes/postgres:18-pgvector-pgroonga"
DOCKERFILE="docker/postgres/Dockerfile"

# Check if image exists
if ! docker image inspect "$IMAGE_NAME" >/dev/null 2>&1; then
    echo "Image $IMAGE_NAME not found, building..."
    docker build -t "$IMAGE_NAME" -f "$DOCKERFILE" docker/postgres
    exit 0
fi

# Get Dockerfile modification time (works on both macOS and Linux)
if [[ "$(uname)" == "Darwin" ]]; then
    DOCKERFILE_MTIME=$(stat -f %m "$DOCKERFILE")
else
    DOCKERFILE_MTIME=$(stat -c %Y "$DOCKERFILE")
fi

# Get image creation time as Unix timestamp
IMAGE_CREATED=$(docker inspect --format '{% raw %}{{.Created}}{% endraw %}' "$IMAGE_NAME")
# Convert ISO 8601 to Unix timestamp (works on both macOS and Linux)
if [[ "$(uname)" == "Darwin" ]]; then
    IMAGE_TIMESTAMP=$(date -j -f "%Y-%m-%dT%H:%M:%S" "${IMAGE_CREATED%%.*}" +%s 2>/dev/null || echo 0)
else
    IMAGE_TIMESTAMP=$(date -d "${IMAGE_CREATED}" +%s 2>/dev/null || echo 0)
fi

# Compare times and rebuild if Dockerfile is newer
if [ "$DOCKERFILE_MTIME" -gt "$IMAGE_TIMESTAMP" ]; then
    echo "Dockerfile is newer than image, rebuilding..."
    docker build -t "$IMAGE_NAME" -f "$DOCKERFILE" docker/postgres
else
    echo "Image $IMAGE_NAME is up to date (skipping build)"
fi
'''

[tasks."build:types:openapi"]
description = "Generate OpenAPI specification and TypeScript types"
dir = "{{vars.server_dir}}"
run = '''
echo "Generating OpenAPI specification..."
uv run python scripts/generate_openapi.py --output openapi.json

echo "Regenerating TypeScript types for Discord bot..."
cd ../{{vars.discord_dir}} && pnpm types:generate

echo "OpenAPI spec and TypeScript types updated!"
'''

# ========================================
# Optimization Tasks
# ========================================

[tasks."optimize:prompts:claim_relevance_check"]
description = "Run full prompt optimization workflow (generate candidates → update prompts)"
run = '''
mise run optimize:prompts:claim_relevance_check:generate_prompt_candidates "$@" && \
mise run optimize:prompts:claim_relevance_check:update_prompts "$@" && \
echo "✓ Prompt optimization workflow complete"
'''

[tasks."optimize:prompts:claim_relevance_check:generate_prompt_candidates"]
description = "Generate optimized prompt candidates using DSPy (step 1)"
dir = "{{vars.server_dir}}"
run = 'uv run python -m src.claim_relevance_check.prompt_optimization.optimize "$@"'
env = { PYTHONPATH = ".", OPENAI_API_BASE = "" }

[tasks."optimize:prompts:claim_relevance_check:update_prompts"]
description = "Compare candidates with current prompts and update if better (step 2)"
dir = "{{vars.server_dir}}"
run = 'uv run python -m src.claim_relevance_check.prompt_optimization.compare_and_update "$@"'
env = { PYTHONPATH = ".", OPENAI_API_BASE = "" }

[tasks."optimize:prompts:claim_relevance_check:augment_dataset"]
description = "Generate candidate examples for the training dataset using LLM"
dir = "{{vars.server_dir}}"
run = 'uv run python -m src.claim_relevance_check.prompt_optimization.augment_dataset "$@"'
env = { PYTHONPATH = ".", OPENAI_API_BASE = "" }

# ========================================
# Validation Tasks
# ========================================

[tasks."validate:api"]
description = "Validate Discord bot endpoints against OpenAPI spec"
depends = ["build:types:openapi"]
run = "python3 opennotes/scripts/validate-api-endpoints.py"
alias = "validate-api"

# ========================================
# Task Configuration
# ========================================

[task_config]
# Run tasks from the project root by default
dir = "{{cwd}}"

# Include additional task files if they exist
includes = [
    ".mise.local.toml",  # Local overrides (git ignored)
    "tasks/"             # Directory with additional task files
]
