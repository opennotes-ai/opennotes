/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/api/v1/auth/register": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Register */
        post: operations["register_api_v1_auth_register_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/auth/login": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Login */
        post: operations["login_api_v1_auth_login_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/auth/refresh": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Refresh Access Token
         * @description Refresh access token using a refresh token.
         *
         *     The refresh token must be provided in the request body (not as a query parameter)
         *     to prevent token leakage in server logs, browser history, and referrer headers.
         */
        post: operations["refresh_access_token_api_v1_auth_refresh_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/auth/logout": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Logout
         * @description Logout by revoking the provided refresh token and current access token.
         *
         *     Only revokes the token if it belongs to the current user, preventing
         *     cross-user token revocation attacks.
         */
        post: operations["logout_api_v1_auth_logout_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/auth/logout-all": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Logout All */
        post: operations["logout_all_api_v1_auth_logout_all_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/auth/revoke-token": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Revoke Current Token */
        post: operations["revoke_current_token_api_v1_auth_revoke_token_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/auth/revoke-all-tokens": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Revoke All Tokens */
        post: operations["revoke_all_tokens_api_v1_auth_revoke_all_tokens_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/users/me": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get Current User Profile */
        get: operations["get_current_user_profile_api_v1_users_me_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /** Update Current User Profile */
        patch: operations["update_current_user_profile_api_v1_users_me_patch"];
        trace?: never;
    };
    "/api/v1/users/me/login-history": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get Login History */
        get: operations["get_login_history_api_v1_users_me_login_history_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/users/me/api-keys": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List User Api Keys */
        get: operations["list_user_api_keys_api_v1_users_me_api_keys_get"];
        put?: never;
        /** Create User Api Key */
        post: operations["create_user_api_key_api_v1_users_me_api_keys_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/users/me/api-keys/{api_key_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /** Revoke User Api Key */
        delete: operations["revoke_user_api_key_api_v1_users_me_api_keys__api_key_id__delete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/profile/auth/discord/init": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Init Discord Oauth
         * @description Initialize Discord OAuth2 flow with CSRF protection.
         *
         *     This endpoint:
         *     1. Generates a cryptographically secure state parameter
         *     2. Stores the state in Redis with a 10-minute TTL
         *     3. Returns the Discord authorization URL with the state parameter
         *
         *     The client should:
         *     1. Store the returned state value
         *     2. Redirect the user to the authorization_url
         *     3. On callback, send both the code AND state to register/login endpoints
         *
         *     Security: The state parameter prevents CSRF attacks by ensuring the OAuth
         *     callback was initiated by this application.
         */
        get: operations["init_discord_oauth_api_v1_profile_auth_discord_init_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/profile/auth/register/discord": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Register Discord
         * @description Register a new user with Discord OAuth2.
         *
         *     This endpoint:
         *     1. Validates the state parameter against stored state (CSRF protection)
         *     2. Exchanges the authorization code for an access token
         *     3. Fetches the user's Discord information to verify identity
         *     4. Creates a new user profile with verified Discord credentials
         *     5. Stores OAuth tokens securely in the credentials field
         *
         *     Security: Prevents CSRF attacks via state validation and identity spoofing
         *     by verifying Discord ownership via OAuth2.
         */
        post: operations["register_discord_api_v1_profile_auth_register_discord_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/profile/auth/register/email": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Register Email */
        post: operations["register_email_api_v1_profile_auth_register_email_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/profile/auth/login/discord": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Login Discord
         * @description Login with Discord OAuth2.
         *
         *     This endpoint:
         *     1. Validates the state parameter against stored state (CSRF protection)
         *     2. Exchanges the authorization code for an access token
         *     3. Fetches the user's Discord information to verify identity
         *     4. Authenticates the user and issues JWT tokens
         *
         *     Security: Prevents CSRF attacks via state validation and verifies
         *     Discord account ownership via OAuth2 before login.
         */
        post: operations["login_discord_api_v1_profile_auth_login_discord_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/profile/auth/login/email": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Login Email */
        post: operations["login_email_api_v1_profile_auth_login_email_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/profile/auth/verify-email": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Verify Email
         * @description Verify a user's email address using the verification token.
         *
         *     This endpoint:
         *     1. Validates the verification token exists and hasn't expired
         *     2. Marks the email as verified
         *     3. Clears the verification token
         *     4. Returns the updated profile
         *
         *     Args:
         *         token: The email verification token sent to the user's email
         *         db: Database session
         *
         *     Returns:
         *         UserProfile: The verified user profile
         *
         *     Raises:
         *         HTTPException 400: If token is invalid or expired
         */
        post: operations["verify_email_api_v1_profile_auth_verify_email_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/profile/auth/resend-verification": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Resend Verification Email
         * @description Resend email verification to a user.
         *
         *     This endpoint:
         *     1. Finds the identity by email
         *     2. Checks if email is already verified
         *     3. Generates new verification token
         *     4. Sends new verification email
         *
         *     Args:
         *         email: The email address to resend verification to
         *         db: Database session
         *
         *     Returns:
         *         dict: Success message
         *
         *     Raises:
         *         HTTPException 400: If email not found or already verified
         */
        post: operations["resend_verification_email_api_v1_profile_auth_resend_verification_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/profile/auth/migrate-profile": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Migrate Legacy User To Profile */
        post: operations["migrate_legacy_user_to_profile_api_v1_profile_auth_migrate_profile_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/profile/me": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get Current Profile Endpoint */
        get: operations["get_current_profile_endpoint_api_v1_profile_me_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /** Update Current Profile Endpoint */
        patch: operations["update_current_profile_endpoint_api_v1_profile_me_patch"];
        trace?: never;
    };
    "/api/v1/profile/auth/revoke": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Revoke Profile Token
         * @description Revoke the current profile access token.
         *
         *     This endpoint:
         *     1. Extracts the token from the Authorization header
         *     2. Adds the token's JTI to the Redis revocation blacklist
         *     3. The token will be rejected on future verification attempts
         *
         *     Use this endpoint to invalidate the current access token after logout
         *     or when a token may be compromised.
         *
         *     Note: Existing tokens without jti claim (created before this feature)
         *     cannot be revoked individually and will expire naturally.
         */
        post: operations["revoke_profile_token_api_v1_profile_auth_revoke_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/admin/profiles/{profile_id}/opennotes-admin": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Opennotes Admin Status
         * @description Get the Open Notes admin status for a user profile.
         *
         *     Args:
         *         profile_id: UUID of the profile to check
         *         db: Database session
         *         _service_account: Service account making the request (required)
         *
         *     Returns:
         *         dict: {"is_opennotes_admin": bool}
         *
         *     Raises:
         *         HTTPException 404: If profile not found
         *         HTTPException 403: If requester is not a service account
         */
        get: operations["get_opennotes_admin_status_api_v1_admin_profiles__profile_id__opennotes_admin_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /**
         * Set Opennotes Admin Status
         * @description Grant or revoke Open Notes admin status for a user profile.
         *
         *     Open Notes admins have cross-community administrative privileges. This endpoint
         *     is restricted to service accounts only.
         *
         *     Args:
         *         profile_id: UUID of the profile to modify
         *         is_admin: True to grant admin status, False to revoke
         *         db: Database session
         *         service_account: Service account making the request
         *
         *     Returns:
         *         UserProfileResponse: Updated profile with new admin status
         *
         *     Raises:
         *         HTTPException 404: If profile not found
         *         HTTPException 403: If requester is not a service account
         */
        patch: operations["set_opennotes_admin_status_api_v1_admin_profiles__profile_id__opennotes_admin_patch"];
        trace?: never;
    };
    "/api/v2/notes": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Notes Jsonapi
         * @description List notes with JSON:API format.
         *
         *     Supports filtering and pagination per JSON:API specification.
         *
         *     Query Parameters:
         *     - page[number]: Page number (default: 1)
         *     - page[size]: Page size (default: 20, max: 100)
         *
         *     Filter Parameters (equality):
         *     - filter[status]: Filter by note status (exact match)
         *     - filter[classification]: Filter by classification
         *     - filter[community_server_id]: Filter by community server UUID
         *     - filter[author_participant_id]: Filter by author
         *     - filter[request_id]: Filter by request ID
         *
         *     Filter Parameters (operators):
         *     - filter[status__neq]: Exclude notes with this status
         *     - filter[created_at__gte]: Notes created on or after this datetime
         *     - filter[created_at__lte]: Notes created on or before this datetime
         *     - filter[rated_by_participant_id__not_in]: Exclude notes rated by these users
         *       (comma-separated list of participant IDs)
         *
         *     Returns JSON:API formatted response with data, jsonapi, links, and meta.
         */
        get: operations["list_notes_jsonapi_api_v2_notes_get"];
        put?: never;
        /**
         * Create Note Jsonapi
         * @description Create a new note with JSON:API format.
         *
         *     JSON:API 1.0 requires:
         *     - Request body with 'data' object containing 'type' and 'attributes'
         *     - Response with 201 Created status
         *     - Response body with 'data' object containing created resource
         *
         *     Returns JSON:API formatted response with data and jsonapi keys.
         */
        post: operations["create_note_jsonapi_api_v2_notes_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v2/notes/{note_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Note Jsonapi
         * @description Get a single note by ID with JSON:API format.
         *
         *     Returns JSON:API formatted response with data and jsonapi keys.
         *     Returns JSON:API error format for 404 and other errors.
         */
        get: operations["get_note_jsonapi_api_v2_notes__note_id__get"];
        put?: never;
        post?: never;
        /**
         * Delete Note Jsonapi
         * @description Delete a note with JSON:API format.
         *
         *     JSON:API 1.0 requires:
         *     - Response with 204 No Content status on success
         *     - Response with JSON:API error format on failure
         *
         *     Returns None (204 No Content) on success.
         */
        delete: operations["delete_note_jsonapi_api_v2_notes__note_id__delete"];
        options?: never;
        head?: never;
        /**
         * Update Note Jsonapi
         * @description Update a note with JSON:API format.
         *
         *     JSON:API 1.0 requires:
         *     - Request body with 'data' object containing 'type', 'id', and 'attributes'
         *     - The 'id' in the body must match the URL parameter
         *     - Response with 200 OK status
         *     - Response body with 'data' object containing updated resource
         *
         *     Returns JSON:API formatted response with data and jsonapi keys.
         */
        patch: operations["update_note_jsonapi_api_v2_notes__note_id__patch"];
        trace?: never;
    };
    "/api/v2/notes/{note_id}/force-publish": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Force Publish Note Jsonapi
         * @description Force-publish a note with JSON:API format (admin only).
         *
         *     This endpoint allows administrators to manually publish notes that haven't met
         *     automatic publication thresholds. The note is marked with force_published flags
         *     for transparency, and the action is logged with admin user ID and timestamp.
         *
         *     Requires admin authentication (service accounts, Open Notes admins, or community admins).
         *
         *     Returns JSON:API formatted response with updated note resource.
         */
        post: operations["force_publish_note_jsonapi_api_v2_notes__note_id__force_publish_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v2/ratings": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create Rating Jsonapi
         * @description Create or upsert a rating with JSON:API format.
         *
         *     JSON:API 1.0 requires:
         *     - Request body with 'data' object containing 'type' and 'attributes'
         *     - Response with 201 Created status for new rating
         *     - Response body with 'data' object containing created/updated resource
         *
         *     If a rating already exists for the same note + rater, it will be updated (upsert).
         */
        post: operations["create_rating_jsonapi_api_v2_ratings_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v2/notes/{note_id}/ratings": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Note Ratings Jsonapi
         * @description List all ratings for a note with JSON:API format.
         *
         *     JSON:API 1.0 requires:
         *     - Response with 200 OK status
         *     - 'data' array containing rating resource objects
         *     - Each resource has 'type', 'id', and 'attributes'
         *
         *     Returns JSON:API formatted response with data and jsonapi keys.
         */
        get: operations["list_note_ratings_jsonapi_api_v2_notes__note_id__ratings_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v2/ratings/{rating_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /**
         * Update Rating Jsonapi
         * @description Update an existing rating with JSON:API format.
         *
         *     JSON:API 1.0 requires:
         *     - Request body with 'data' object containing 'type', 'id', and 'attributes'
         *     - Response with 200 OK status for updated resource
         *     - Response body with 'data' object containing updated resource
         *
         *     Users can only update ratings they submitted or if they are a community admin.
         *     Service accounts can update any rating.
         */
        put: operations["update_rating_jsonapi_api_v2_ratings__rating_id__put"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v2/notes/{note_id}/ratings/stats": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Rating Stats Jsonapi
         * @description Get rating statistics for a note with JSON:API format.
         *
         *     JSON:API 1.0 requires:
         *     - Response with 200 OK status
         *     - 'data' object containing singleton/aggregate resource
         *     - Resource has 'type', 'id', and 'attributes'
         *
         *     Users can only view rating stats for notes in communities they are members of.
         *     Service accounts can view all rating stats.
         */
        get: operations["get_rating_stats_jsonapi_api_v2_notes__note_id__ratings_stats_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v2/profiles/me": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Current Profile Jsonapi
         * @description Get the authenticated user's profile with JSON:API format.
         *
         *     Returns JSON:API formatted response with data and jsonapi keys.
         */
        get: operations["get_current_profile_jsonapi_api_v2_profiles_me_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /**
         * Update Profile Jsonapi
         * @description Update the authenticated user's profile with JSON:API format.
         *
         *     Accepts JSON:API formatted request body with data object containing
         *     type, id, and attributes.
         *
         *     Returns JSON:API formatted response with updated profile.
         */
        patch: operations["update_profile_jsonapi_api_v2_profiles_me_patch"];
        trace?: never;
    };
    "/api/v2/profiles/me/identities": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List User Identities Jsonapi
         * @description List all identities linked to the current user's profile with JSON:API format.
         *
         *     Returns JSON:API formatted response with data array and jsonapi keys.
         *
         *     Query Parameters:
         *         limit: Maximum number of identities to return (1-100, default 50)
         *         offset: Number of identities to skip (>=0, default 0)
         */
        get: operations["list_user_identities_jsonapi_api_v2_profiles_me_identities_get"];
        put?: never;
        /**
         * Link Identity Jsonapi
         * @description Link a new authentication identity to the current user's profile.
         *
         *     JSON:API POST request should use standard JSON:API request body format
         *     with data object containing type and attributes.
         *
         *     Security: Requires oauth_verified in credentials to prevent linking
         *     accounts the user doesn't own.
         */
        post: operations["link_identity_jsonapi_api_v2_profiles_me_identities_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v2/profiles/me/identities/{identity_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Unlink Identity Jsonapi
         * @description Unlink an authentication identity from the current user's profile.
         *
         *     Note: Cannot unlink the last remaining identity. Users must have at least
         *     one authentication method linked to their profile.
         *
         *     Returns 204 No Content on success.
         */
        delete: operations["unlink_identity_jsonapi_api_v2_profiles_me_identities__identity_id__delete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v2/profiles/me/communities": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List User Communities Jsonapi
         * @description List all communities the current user is a member of with JSON:API format.
         *
         *     Returns JSON:API formatted response with data array and jsonapi keys.
         *
         *     Query Parameters:
         *         limit: Maximum number of communities to return (1-100, default 50)
         *         offset: Number of communities to skip (>=0, default 0)
         */
        get: operations["list_user_communities_jsonapi_api_v2_profiles_me_communities_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v2/profiles/{profile_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Public Profile Jsonapi
         * @description Get a public profile by ID with JSON:API format.
         *
         *     Returns JSON:API formatted response with data and jsonapi keys.
         *     Returns JSON:API error format for 404 and other errors.
         */
        get: operations["get_public_profile_jsonapi_api_v2_profiles__profile_id__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v2/profiles/{profile_id}/opennotes-admin": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Admin Status Jsonapi
         * @description Get the Open Notes admin status for a user profile.
         *
         *     Returns JSON:API formatted response with admin status data.
         *
         *     Security: This endpoint is restricted to service accounts only.
         */
        get: operations["get_admin_status_jsonapi_api_v2_profiles__profile_id__opennotes_admin_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /**
         * Update Admin Status Jsonapi
         * @description Grant or revoke Open Notes admin status for a user profile.
         *
         *     JSON:API PATCH request should use standard JSON:API request body format
         *     with data object containing type, id, and attributes.
         *
         *     Security: This endpoint is restricted to service accounts only.
         */
        patch: operations["update_admin_status_jsonapi_api_v2_profiles__profile_id__opennotes_admin_patch"];
        trace?: never;
    };
    "/api/v2/community-servers/lookup": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Lookup Community Server Jsonapi
         * @description Look up a community server by platform and platform ID with JSON:API format.
         *
         *     Returns the internal UUID for a community server based on its platform-specific identifier.
         *     Auto-creates the community server if it doesn't exist (for service accounts/bots).
         *
         *     Args:
         *         platform: Platform type (default: "discord")
         *         platform_id: Platform-specific ID (e.g., Discord guild ID)
         *
         *     Returns:
         *         JSON:API formatted response with community server details
         *
         *     Raises:
         *         404: If community server not found and user is not a service account
         */
        get: operations["lookup_community_server_jsonapi_api_v2_community_servers_lookup_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v2/community-servers/{server_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Community Server Jsonapi
         * @description Get a community server by ID with JSON:API format.
         *
         *     Returns JSON:API formatted response with data and jsonapi keys.
         *     Returns JSON:API error format for 404 and other errors.
         */
        get: operations["get_community_server_jsonapi_api_v2_community_servers__server_id__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v2/stats/notes": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Notes Stats Jsonapi
         * @description Get aggregated note statistics in JSON:API format.
         *
         *     Returns statistics about notes including total count, helpful/not helpful counts,
         *     pending count, and average helpfulness score.
         *
         *     Query Parameters:
         *     - filter[date_from]: Notes created on or after this datetime
         *     - filter[date_to]: Notes created on or before this datetime
         *     - filter[community_server_id]: Filter by community server UUID
         *
         *     Users can only see stats from communities they are members of.
         *     Service accounts can see all stats.
         */
        get: operations["get_notes_stats_jsonapi_api_v2_stats_notes_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v2/stats/participant/{participant_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Participant Stats Jsonapi
         * @description Get statistics for a specific participant in JSON:API format.
         *
         *     Returns statistics about a participant including notes created, ratings given,
         *     average helpfulness received, and top classification.
         *
         *     Path Parameters:
         *     - participant_id: The participant ID to get statistics for
         *
         *     Query Parameters:
         *     - filter[community_server_id]: Filter by community server UUID
         *
         *     Users can only see stats from communities they are members of.
         *     Service accounts can see all stats.
         */
        get: operations["get_participant_stats_jsonapi_api_v2_stats_participant__participant_id__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v2/requests": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Requests Jsonapi
         * @description List requests with JSON:API format.
         *
         *     Supports filtering and pagination per JSON:API specification.
         *
         *     Query Parameters:
         *     - page[number]: Page number (default: 1)
         *     - page[size]: Page size (default: 20, max: 100)
         *
         *     Filter Parameters:
         *     - filter[status]: Filter by request status (PENDING, IN_PROGRESS, COMPLETED, FAILED)
         *     - filter[community_server_id]: Filter by community server UUID
         *     - filter[requested_by]: Filter by requester participant ID
         *     - filter[requested_at__gte]: Requests created on or after this datetime
         *     - filter[requested_at__lte]: Requests created on or before this datetime
         *
         *     Returns JSON:API formatted response with data, jsonapi, links, and meta.
         */
        get: operations["list_requests_jsonapi_api_v2_requests_get"];
        put?: never;
        /**
         * Create Request Jsonapi
         * @description Create a new request with JSON:API format.
         *
         *     JSON:API 1.1 requires:
         *     - Request body with 'data' object containing 'type' and 'attributes'
         *     - Response with 201 Created status
         *     - Response body with 'data' object containing created resource
         *
         *     Returns JSON:API formatted response with data and jsonapi keys.
         */
        post: operations["create_request_jsonapi_api_v2_requests_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v2/requests/{request_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Request Jsonapi
         * @description Get a single request by ID with JSON:API format.
         *
         *     Returns JSON:API formatted response with data and jsonapi keys.
         *     Returns JSON:API error format for 404 and other errors.
         */
        get: operations["get_request_jsonapi_api_v2_requests__request_id__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /**
         * Update Request Jsonapi
         * @description Update a request with JSON:API format.
         *
         *     JSON:API 1.1 requires:
         *     - Request body with 'data' object containing 'type', 'id', and 'attributes'
         *     - The 'id' in the body must match the URL parameter
         *     - Response with 200 OK status
         *     - Response body with 'data' object containing updated resource
         *
         *     Returns JSON:API formatted response with data and jsonapi keys.
         */
        patch: operations["update_request_jsonapi_api_v2_requests__request_id__patch"];
        trace?: never;
    };
    "/api/v2/scoring/status": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Scoring Status Jsonapi
         * @description Get system scoring status in JSON:API format.
         *
         *     Returns a singleton resource with current scoring system status including:
         *     - Current note count
         *     - Active scoring tier
         *     - Data confidence level
         *     - Tier thresholds
         *     - Next tier upgrade information
         *     - Performance metrics
         *     - Warnings
         */
        get: operations["get_scoring_status_jsonapi_api_v2_scoring_status_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v2/scoring/notes/{note_id}/score": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Note Score Jsonapi
         * @description Get individual note score in JSON:API format.
         *
         *     Users can only view scores for notes in communities they are members of.
         *     Service accounts can view all scores.
         *
         *     Returns the calculated score for a specific note along with:
         *     - Algorithm used for scoring
         *     - Confidence level based on rating count
         *     - Current scoring tier information
         *     - Number of ratings
         *     - Timestamp of calculation
         */
        get: operations["get_note_score_jsonapi_api_v2_scoring_notes__note_id__score_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v2/scoring/notes/batch-scores": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Get Batch Scores Jsonapi
         * @description Get scores for multiple notes in JSON:API format.
         *
         *     JSON:API request body must contain:
         *     - data.type: "batch-score-requests"
         *     - data.attributes.note_ids: list of note UUIDs
         *
         *     Users can only get scores for notes in communities they are members of.
         *     Notes from other communities will be treated as "not found" in the response.
         *     Service accounts can access all notes.
         *
         *     Returns a list of note score resources with meta information about
         *     total requested vs found counts.
         */
        post: operations["get_batch_scores_jsonapi_api_v2_scoring_notes_batch_scores_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v2/scoring/notes/top": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Top Notes Jsonapi
         * @description Get top-scored notes in JSON:API format.
         *
         *     Users can only see notes from communities they are members of.
         *     Service accounts can see all notes.
         *
         *     Returns the highest-scored notes with:
         *     - Score and confidence metadata
         *     - Tier information
         *     - Rating counts
         *     - Optional filtering by confidence level and tier
         *
         *     Query Parameters:
         *     - limit: Number of results (1-100, default 10)
         *     - min_confidence: Filter by confidence level (no_data, provisional, standard)
         *     - tier: Filter by scoring tier (0-5)
         *     - batch_size: Processing batch size (100-5000, default 1000)
         *     - community_server_id: Filter by community server UUID
         */
        get: operations["get_top_notes_jsonapi_api_v2_scoring_notes_top_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v2/monitored-channels": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Monitored Channels Jsonapi
         * @description List monitored channels with JSON:API format.
         *
         *     Supports filtering and pagination per JSON:API specification.
         *
         *     Query Parameters:
         *     - page[number]: Page number (default: 1)
         *     - page[size]: Page size (default: 20, max: 100)
         *
         *     Filter Parameters:
         *     - filter[community_server_id]: Filter by community server platform ID (required)
         *     - filter[enabled]: Filter by enabled status
         *
         *     Returns JSON:API formatted response with data, jsonapi, links, and meta.
         */
        get: operations["list_monitored_channels_jsonapi_api_v2_monitored_channels_get"];
        put?: never;
        /**
         * Create Monitored Channel Jsonapi
         * @description Create a new monitored channel with JSON:API format.
         *
         *     JSON:API 1.1 requires:
         *     - Request body with 'data' object containing 'type' and 'attributes'
         *     - Response with 201 Created status
         *     - Response body with 'data' object containing created resource
         *
         *     Returns JSON:API formatted response with data and jsonapi keys.
         */
        post: operations["create_monitored_channel_jsonapi_api_v2_monitored_channels_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v2/monitored-channels/{channel_uuid}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Monitored Channel Jsonapi
         * @description Get a single monitored channel by ID with JSON:API format.
         *
         *     Returns JSON:API formatted response with data and jsonapi keys.
         *     Returns JSON:API error format for 404 and other errors.
         */
        get: operations["get_monitored_channel_jsonapi_api_v2_monitored_channels__channel_uuid__get"];
        put?: never;
        post?: never;
        /**
         * Delete Monitored Channel Jsonapi
         * @description Delete a monitored channel with JSON:API format.
         *
         *     JSON:API 1.1 requires:
         *     - Response with 204 No Content status on success
         *     - No response body on success
         *     - JSON:API error format for errors
         *
         *     Returns 204 No Content on success, JSON:API error on failure.
         */
        delete: operations["delete_monitored_channel_jsonapi_api_v2_monitored_channels__channel_uuid__delete"];
        options?: never;
        head?: never;
        /**
         * Update Monitored Channel Jsonapi
         * @description Update a monitored channel with JSON:API format.
         *
         *     JSON:API 1.1 requires:
         *     - Request body with 'data' object containing 'type', 'id', and 'attributes'
         *     - The 'id' in the body must match the URL parameter
         *     - Response with 200 OK status
         *     - Response body with 'data' object containing updated resource
         *
         *     Returns JSON:API formatted response with data and jsonapi keys.
         */
        patch: operations["update_monitored_channel_jsonapi_api_v2_monitored_channels__channel_uuid__patch"];
        trace?: never;
    };
    "/api/v2/note-publisher-configs": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Note Publisher Configs Jsonapi
         * @description List note publisher configs with JSON:API format.
         *
         *     Supports filtering and pagination per JSON:API specification.
         *
         *     Query Parameters:
         *     - page[number]: Page number (default: 1)
         *     - page[size]: Page size (default: 20, max: 100)
         *
         *     Filter Parameters:
         *     - filter[community_server_id]: Filter by community server platform ID (required)
         *     - filter[enabled]: Filter by enabled status
         *
         *     Returns JSON:API formatted response with data, jsonapi, links, and meta.
         */
        get: operations["list_note_publisher_configs_jsonapi_api_v2_note_publisher_configs_get"];
        put?: never;
        /**
         * Create Note Publisher Config Jsonapi
         * @description Create a new note publisher config with JSON:API format.
         *
         *     JSON:API 1.1 requires:
         *     - Request body with 'data' object containing 'type' and 'attributes'
         *     - Response with 201 Created status
         *     - Response body with 'data' object containing created resource
         *
         *     Returns JSON:API formatted response with data and jsonapi keys.
         */
        post: operations["create_note_publisher_config_jsonapi_api_v2_note_publisher_configs_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v2/note-publisher-configs/{config_uuid}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Note Publisher Config Jsonapi
         * @description Get a single note publisher config by ID with JSON:API format.
         *
         *     Returns JSON:API formatted response with data and jsonapi keys.
         *     Returns JSON:API error format for 404 and other errors.
         */
        get: operations["get_note_publisher_config_jsonapi_api_v2_note_publisher_configs__config_uuid__get"];
        put?: never;
        post?: never;
        /**
         * Delete Note Publisher Config Jsonapi
         * @description Delete a note publisher config with JSON:API format.
         *
         *     JSON:API 1.1 requires:
         *     - Response with 204 No Content status on success
         *     - No response body on success
         *     - JSON:API error format for errors
         *
         *     Returns 204 No Content on success, JSON:API error on failure.
         */
        delete: operations["delete_note_publisher_config_jsonapi_api_v2_note_publisher_configs__config_uuid__delete"];
        options?: never;
        head?: never;
        /**
         * Update Note Publisher Config Jsonapi
         * @description Update a note publisher config with JSON:API format.
         *
         *     JSON:API 1.1 requires:
         *     - Request body with 'data' object containing 'type', 'id', and 'attributes'
         *     - The 'id' in the body must match the URL parameter
         *     - Response with 200 OK status
         *     - Response body with 'data' object containing updated resource
         *
         *     Returns JSON:API formatted response with data and jsonapi keys.
         */
        patch: operations["update_note_publisher_config_jsonapi_api_v2_note_publisher_configs__config_uuid__patch"];
        trace?: never;
    };
    "/api/v2/note-publisher-posts": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Note Publisher Posts Jsonapi
         * @description List note publisher posts with JSON:API format.
         *
         *     Supports filtering and pagination per JSON:API specification.
         *
         *     Query Parameters:
         *     - page[number]: Page number (default: 1)
         *     - page[size]: Page size (default: 20, max: 100)
         *
         *     Filter Parameters:
         *     - filter[community_server_id]: Filter by community server platform ID (required)
         *     - filter[channel_id]: Filter by Discord channel ID
         *     - filter[success]: Filter by success status
         *
         *     Returns JSON:API formatted response with data, jsonapi, links, and meta.
         */
        get: operations["list_note_publisher_posts_jsonapi_api_v2_note_publisher_posts_get"];
        put?: never;
        /**
         * Create Note Publisher Post Jsonapi
         * @description Create a new note publisher post record with JSON:API format.
         *
         *     JSON:API 1.1 requires:
         *     - Request body with 'data' object containing 'type' and 'attributes'
         *     - Response with 201 Created status
         *     - Response body with 'data' object containing created resource
         *
         *     Returns JSON:API formatted response with data and jsonapi keys.
         */
        post: operations["create_note_publisher_post_jsonapi_api_v2_note_publisher_posts_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v2/note-publisher-posts/{post_uuid}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Note Publisher Post Jsonapi
         * @description Get a single note publisher post by ID with JSON:API format.
         *
         *     Returns JSON:API formatted response with data and jsonapi keys.
         *     Returns JSON:API error format for 404 and other errors.
         */
        get: operations["get_note_publisher_post_jsonapi_api_v2_note_publisher_posts__post_uuid__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v2/previously-seen-messages": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Previously Seen Messages Jsonapi
         * @description List previously seen messages with JSON:API format.
         *
         *     Supports filtering and pagination per JSON:API specification.
         *
         *     Query Parameters:
         *     - page[number]: Page number (default: 1)
         *     - page[size]: Page size (default: 20, max: 100)
         *
         *     Filter Parameters:
         *     - filter[community_server_id]: Filter by community server UUID (required)
         *
         *     Returns JSON:API formatted response with data, jsonapi, links, and meta.
         */
        get: operations["list_previously_seen_messages_jsonapi_api_v2_previously_seen_messages_get"];
        put?: never;
        /**
         * Create Previously Seen Message Jsonapi
         * @description Create a new previously seen message with JSON:API format.
         *
         *     JSON:API 1.1 requires:
         *     - Request body with 'data' object containing 'type' and 'attributes'
         *     - Response with 201 Created status
         *     - Response body with 'data' object containing created resource
         *
         *     Returns JSON:API formatted response with data and jsonapi keys.
         */
        post: operations["create_previously_seen_message_jsonapi_api_v2_previously_seen_messages_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v2/previously-seen-messages/{message_uuid}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Previously Seen Message Jsonapi
         * @description Get a single previously seen message by ID with JSON:API format.
         *
         *     Returns JSON:API formatted response with data and jsonapi keys.
         *     Returns JSON:API error format for 404 and other errors.
         */
        get: operations["get_previously_seen_message_jsonapi_api_v2_previously_seen_messages__message_uuid__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v2/previously-seen-messages/check": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Check Previously Seen Jsonapi
         * @description Check if a message has been seen before with JSON:API format.
         *
         *     This endpoint:
         *     1. Generates an embedding for the message text
         *     2. Searches for similar previously seen messages
         *     3. Resolves thresholds (channel override or global config)
         *     4. Returns action recommendations (auto-publish/auto-request)
         *
         *     JSON:API 1.1 action endpoint that returns check results.
         */
        post: operations["check_previously_seen_jsonapi_api_v2_previously_seen_messages_check_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v2/similarity-searches": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Similarity Search Jsonapi
         * @description Perform semantic similarity search on fact-check items.
         *
         *     This endpoint:
         *     1. Verifies user is authorized member of community server
         *     2. Validates community server has OpenAI configuration
         *     3. Generates embedding using text-embedding-3-small (1536 dimensions)
         *     4. Queries fact_check_items table with pgvector cosine similarity
         *     5. Filters by dataset_tags (e.g., 'snopes', 'politifact')
         *     6. Returns top matches above similarity threshold
         *
         *     JSON:API 1.1 action endpoint that returns search results.
         *
         *     Rate Limiting:
         *     - Per-user rate limit: 100 requests/hour
         *     - Per-community rate limits: Based on configured LLM usage limits
         *     - OpenAI API rate limits: Automatic detection with retry guidance
         */
        post: operations["similarity_search_jsonapi_api_v2_similarity_searches_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/notes": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Notes
         * @description List notes with filters and pagination.
         *
         *     Users can only see notes from communities they are members of.
         *     Service accounts can see all notes.
         */
        get: operations["list_notes_api_v1_notes_get"];
        put?: never;
        /**
         * Create Note
         * @description Create a new community note
         */
        post: operations["create_note_api_v1_notes_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/notes/{note_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Note
         * @description Get a specific note by ID.
         *
         *     Users can only view notes from communities they are members of.
         *     Service accounts can view all notes.
         */
        get: operations["get_note_api_v1_notes__note_id__get"];
        put?: never;
        post?: never;
        /**
         * Delete Note
         * @description Delete a note.
         *
         *     Users can only delete notes they authored or if they are a community admin.
         *     Service accounts can delete any note.
         */
        delete: operations["delete_note_api_v1_notes__note_id__delete"];
        options?: never;
        head?: never;
        /**
         * Update Note
         * @deprecated
         * @description Update a note.
         *
         *     Deprecated: Use JSON:API endpoint PATCH /jsonapi/notes/{note_id} instead.
         *
         *     Users can only update notes they authored or if they are a community admin.
         *     Service accounts can update any note.
         */
        patch: operations["update_note_api_v1_notes__note_id__patch"];
        trace?: never;
    };
    "/api/v1/notes/{note_id}/force-publish": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Force Publish Note
         * @description Force-publish a note (admin only).
         *
         *     This endpoint allows administrators to manually publish notes that haven't met
         *     automatic publication thresholds. The note is marked with force_published flags
         *     for transparency, and the action is logged with admin user ID and timestamp.
         *
         *     Requires admin authentication (service accounts, Open Notes admins, or community admins).
         */
        post: operations["force_publish_note_api_v1_notes__note_id__force_publish_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/requests": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Requests
         * @description List requests with filters and pagination.
         *
         *     Users can only see requests from communities they are members of.
         *     Service accounts can see all requests.
         */
        get: operations["list_requests_api_v1_requests_get"];
        put?: never;
        /**
         * Create Request
         * @description Create a new note request
         */
        post: operations["create_request_api_v1_requests_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/requests/{request_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Request
         * @description Get a specific request.
         *
         *     Users can only view requests from communities they are members of.
         *     Service accounts can view all requests.
         */
        get: operations["get_request_api_v1_requests__request_id__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /**
         * Update Request
         * @description Update a request status.
         *
         *     Users can only update requests they created or if they are a community admin.
         *     Service accounts can update any request.
         */
        patch: operations["update_request_api_v1_requests__request_id__patch"];
        trace?: never;
    };
    "/api/v1/requests/{request_id}/generate-ai-note": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Generate Ai Note
         * @description Generate an AI-powered note for a specific request.
         *
         *     This endpoint triggers on-demand AI note generation for requests that have
         *     associated fact-check data. The AI will analyze the original message and
         *     the matched fact-check information to generate a helpful community note.
         *
         *     Requirements:
         *     - Request must exist and have fact-check metadata (dataset_item_id, similarity_score, dataset_name)
         *     - AI note writing must be enabled for the community server
         *     - Rate limits: 5 per minute, 20 per hour
         *
         *     Returns:
         *         NoteResponse: The generated AI note
         */
        post: operations["generate_ai_note_api_v1_requests__request_id__generate_ai_note_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/stats/notes": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Notes Stats
         * @description Get aggregated note statistics.
         *
         *     Users can only see stats from communities they are members of.
         *     Service accounts can see all stats.
         */
        get: operations["get_notes_stats_api_v1_stats_notes_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/stats/participant/{participant_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Participant Stats
         * @description Get statistics for a specific participant.
         *
         *     Users can only see stats from communities they are members of.
         *     Service accounts can see all stats.
         */
        get: operations["get_participant_stats_api_v1_stats_participant__participant_id__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/scoring/status": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get Scoring Status */
        get: operations["get_scoring_status_api_v1_scoring_status_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/scoring/notes/{note_id}/score": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Note Score
         * @description Get individual note score with metadata.
         *
         *     Users can only view scores for notes in communities they are members of.
         *     Service accounts can view all scores.
         *
         *     Returns the calculated score for a specific note along with:
         *     - Algorithm used for scoring
         *     - Confidence level based on rating count
         *     - Current scoring tier information
         *     - Number of ratings
         *     - Timestamp of calculation
         *
         *     Returns:
         *         - 200: Score calculated successfully
         *         - 403: User not member of note's community
         *         - 404: Note not found
         *         - 500: Server error
         */
        get: operations["get_note_score_api_v1_scoring_notes__note_id__score_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/scoring/notes/batch-scores": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Get Batch Note Scores
         * @description Get scores for multiple notes in a single request.
         *
         *     Users can only get scores for notes in communities they are members of.
         *     Notes from other communities will be treated as "not found" in the response.
         *     Service accounts can access all notes.
         *
         *     Efficiently retrieves scores for multiple notes to prevent N+1 query patterns.
         *     Returns a map of note IDs to their score responses, along with a list of
         *     note IDs that were not found.
         *
         *     Args:
         *         request: BatchScoreRequest containing list of note IDs
         *
         *     Returns:
         *         - 200: Scores retrieved successfully (includes partial results)
         *         - 400: Invalid request (empty list, too many IDs)
         *         - 500: Server error
         *
         *     Performance: This endpoint processes all notes in a single database query
         *     and calculates scores efficiently, reducing overhead compared to individual
         *     requests for each note.
         */
        post: operations["get_batch_note_scores_api_v1_scoring_notes_batch_scores_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/scoring/notes/top": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Top Notes
         * @description Get top-scored notes with optional filtering.
         *
         *     Users can only see notes from communities they are members of.
         *     Service accounts can see all notes.
         *
         *     Returns the highest-scored notes in the system with:
         *     - Score and confidence metadata
         *     - Tier information
         *     - Rating counts
         *     - Optional filtering by confidence level and tier
         *
         *     Uses batch processing to prevent memory exhaustion with large note counts.
         *
         *     Query Parameters:
         *         - limit: Number of results (1-100, default 10)
         *         - min_confidence: Filter by confidence level
         *         - tier: Filter by scoring tier (0-5)
         *         - batch_size: Number of notes to process per batch (100-5000, default 1000)
         *         - community_server_id: Filter by community server (UUID)
         *
         *     Returns:
         *         - 200: Top notes retrieved successfully
         *         - 403: User not member of specified community
         *         - 500: Server error
         */
        get: operations["get_top_notes_api_v1_scoring_notes_top_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/scoring/score": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Score Notes */
        post: operations["score_notes_api_v1_scoring_score_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/scoring/health": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Scoring Health */
        get: operations["scoring_health_api_v1_scoring_health_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/note-publisher/config": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Note Publisher Config
         * @description Get auto-post configuration for a server or channel.
         *
         *     Users can only view config for communities they are members of.
         *     Service accounts can view all configs.
         *
         *     If channel_id is provided, returns channel-specific config if it exists,
         *     otherwise returns server-wide config.
         */
        get: operations["get_note_publisher_config_api_v1_note_publisher_config_get"];
        put?: never;
        /**
         * Set Note Publisher Config
         * @description Create or update auto-post configuration for a server or channel.
         *
         *     Channel-specific configs (channel_id set) override server-wide configs (channel_id=None).
         */
        post: operations["set_note_publisher_config_api_v1_note_publisher_config_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/note-publisher/record": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Record Note Publisher
         * @description Record an auto-post attempt (successful or failed) for audit trail.
         *
         *     If the post was successful and embedding data is provided, also stores
         *     the message embedding for duplicate detection.
         */
        post: operations["record_note_publisher_api_v1_note_publisher_record_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/note-publisher/check-duplicate/{original_message_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Check Duplicate
         * @description Check if an auto-post already exists for the given original message ID.
         */
        get: operations["check_duplicate_api_v1_note_publisher_check_duplicate__original_message_id__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/note-publisher/last-post/{channel_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Last Post
         * @description Get the most recent auto-post in a channel (for cooldown checking).
         *
         *     Users can only view posts for communities they are members of.
         *     Service accounts can view all posts.
         *
         *     Requires community_server_id query parameter for membership verification.
         */
        get: operations["get_last_post_api_v1_note_publisher_last_post__channel_id__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/webhooks/discord/interactions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Handle Discord Interaction */
        post: operations["handle_discord_interaction_api_v1_webhooks_discord_interactions_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/webhooks/register": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Register Webhook */
        post: operations["register_webhook_api_v1_webhooks_register_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/webhooks/{community_server_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get Webhooks By Community Server */
        get: operations["get_webhooks_by_community_server_api_v1_webhooks__community_server_id__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/webhooks/{webhook_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /** Update Webhook */
        put: operations["update_webhook_api_v1_webhooks__webhook_id__put"];
        post?: never;
        /** Delete Webhook */
        delete: operations["delete_webhook_api_v1_webhooks__webhook_id__delete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/webhooks/health/webhooks": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Webhook Health */
        get: operations["webhook_health_api_v1_webhooks_health_webhooks_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/webhooks/stats/{community_server_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get Community Server Stats */
        get: operations["get_community_server_stats_api_v1_webhooks_stats__community_server_id__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/webhooks/tasks/by-interaction/{interaction_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get Task By Interaction */
        get: operations["get_task_by_interaction_api_v1_webhooks_tasks_by_interaction__interaction_id__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/webhooks/tasks/{task_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get Task By Id */
        get: operations["get_task_by_id_api_v1_webhooks_tasks__task_id__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/config/rating-thresholds": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Rating Thresholds
         * @description Get rating threshold configuration values.
         *
         *     These values define the minimum number of ratings and unique raters required
         *     before a note can receive CURRENTLY_RATED_HELPFUL or CURRENTLY_RATED_NOT_HELPFUL status.
         *
         *     The thresholds should match the Community Notes scoring algorithm defaults.
         */
        get: operations["get_rating_thresholds_api_v1_config_rating_thresholds_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/community-config/{community_server_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Community Config
         * @description Get all configuration settings for a specific community server.
         *
         *     Accepts a platform-specific community ID (e.g., Discord guild ID) and looks up
         *     the corresponding community server.
         *
         *     Returns a dictionary of config_key: config_value pairs for the community server.
         *     If no configuration exists, returns an empty dictionary.
         *
         *     Requires: User must be a member of the community server.
         *     Service accounts can view all configs.
         */
        get: operations["get_community_config_api_v1_community_config__community_server_id__get"];
        /**
         * Set Community Config
         * @description Set or update a configuration value for a specific community server.
         *
         *     Accepts a platform-specific community ID (e.g., Discord guild ID) and looks up
         *     the corresponding community server. If the key already exists, it will be updated.
         *     Otherwise, a new entry is created. The updated_by field tracks who made the change
         *     for audit purposes.
         *
         *     Requires: User must be an admin or moderator of the community server.
         */
        put: operations["set_community_config_api_v1_community_config__community_server_id__put"];
        post?: never;
        /**
         * Reset Community Config
         * @description Reset community server configuration to defaults.
         *
         *     Accepts a platform-specific community ID (e.g., Discord guild ID) and looks up
         *     the corresponding community server. If config_key is provided, only that specific
         *     key is deleted. If config_key is None, all configuration for the community server
         *     is deleted.
         *
         *     Requires: User must be an admin or moderator of the community server.
         */
        delete: operations["reset_community_config_api_v1_community_config__community_server_id__delete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/community-servers/lookup": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Lookup Community Server
         * @description Look up a community server by platform and platform ID.
         *
         *     Returns the internal UUID for a community server based on its platform-specific identifier.
         *     Auto-creates the community server if it doesn't exist (for service accounts/bots).
         *
         *     Args:
         *         platform: Platform type (default: "discord")
         *         platform_id: Platform-specific ID (e.g., Discord guild ID)
         *
         *     Returns:
         *         Community server details including internal UUID
         *
         *     Raises:
         *         404: If community server not found and user is not a service account
         */
        get: operations["lookup_community_server_api_v1_community_servers_lookup_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/community-servers/{community_server_id}/admins": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Community Admins
         * @description List all admins for a specific community server.
         *
         *     Returns admins with their sources of admin privileges:
         *     - Open Notes platform admin (is_opennotes_admin=True)
         *     - Community admin (role='admin')
         *     - Discord Manage Server permission (checked by Discord bot)
         *
         *     Args:
         *         community_server_id: Discord guild ID
         *         db: Database session
         *         current_user: Current authenticated user
         *         http_request: FastAPI Request object
         *
         *     Returns:
         *         List of CommunityAdminResponse with admin information
         *
         *     Raises:
         *         HTTPException 404: Community server not found
         *         HTTPException 403: Not authorized
         */
        get: operations["list_community_admins_api_v1_community_servers__community_server_id__admins_get"];
        put?: never;
        /**
         * Add Community Admin
         * @description Add a user as admin for a specific community server.
         *
         *     Sets CommunityMember.role = 'admin' for the specified user. Requires the requester
         *     to have existing admin privileges (service account, Open Notes admin, community admin,
         *     or Discord Manage Server permission).
         *
         *     Args:
         *         community_server_id: Discord guild ID
         *         request_body: Request containing user_discord_id
         *         db: Database session
         *         current_user: Current authenticated user
         *         http_request: FastAPI Request object
         *
         *     Returns:
         *         CommunityAdminResponse: Updated community member information
         *
         *     Raises:
         *         HTTPException 404: Community server or user not found
         *         HTTPException 403: Not authorized (not an admin)
         *         HTTPException 400: Invalid input
         */
        post: operations["add_community_admin_api_v1_community_servers__community_server_id__admins_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/community-servers/{community_server_id}/admins/{user_discord_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Remove Community Admin
         * @description Remove admin status from a user in a specific community server.
         *
         *     Sets CommunityMember.role = 'member'. Prevents removing the last admin to ensure
         *     the community always has at least one admin.
         *
         *     Args:
         *         community_server_id: Discord guild ID
         *         user_discord_id: Discord ID of user to demote
         *         db: Database session
         *         current_user: Current authenticated user
         *         http_request: FastAPI Request object
         *
         *     Returns:
         *         RemoveCommunityAdminResponse: Operation result
         *
         *     Raises:
         *         HTTPException 404: Community server or user not found
         *         HTTPException 403: Not authorized (not an admin)
         *         HTTPException 409: Cannot remove last admin
         */
        delete: operations["remove_community_admin_api_v1_community_servers__community_server_id__admins__user_discord_id__delete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/community-servers/{community_server_id}/llm-config": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Llm Configs
         * @description List all LLM configurations for a community server.
         *
         *     Requires admin or moderator access to the community server.
         */
        get: operations["list_llm_configs_api_v1_community_servers__community_server_id__llm_config_get"];
        put?: never;
        /**
         * Create Llm Config
         * @description Create a new LLM configuration for a community server.
         *
         *     Requires admin or moderator access to the community server.
         */
        post: operations["create_llm_config_api_v1_community_servers__community_server_id__llm_config_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/community-servers/{community_server_id}/llm-config/{provider}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Llm Config
         * @description Get a specific LLM configuration.
         *
         *     Requires admin or moderator access to the community server.
         */
        get: operations["get_llm_config_api_v1_community_servers__community_server_id__llm_config__provider__get"];
        put?: never;
        post?: never;
        /**
         * Delete Llm Config
         * @description Delete an LLM configuration.
         *
         *     Requires admin or moderator access to the community server.
         */
        delete: operations["delete_llm_config_api_v1_community_servers__community_server_id__llm_config__provider__delete"];
        options?: never;
        head?: never;
        /**
         * Update Llm Config
         * @description Update an existing LLM configuration.
         *
         *     Requires admin or moderator access to the community server.
         */
        patch: operations["update_llm_config_api_v1_community_servers__community_server_id__llm_config__provider__patch"];
        trace?: never;
    };
    "/api/v1/community-servers/{community_server_id}/llm-config/test": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Test Llm Config
         * @description Test an LLM configuration without saving it.
         *
         *     Validates the API key and checks connectivity.
         *     Requires admin or moderator access to the community server.
         */
        post: operations["test_llm_config_api_v1_community_servers__community_server_id__llm_config_test_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/community-servers/{community_server_id}/llm-config/{provider}/usage": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Usage Stats
         * @description Get usage statistics for an LLM configuration.
         *
         *     Requires admin or moderator access to the community server.
         */
        get: operations["get_usage_stats_api_v1_community_servers__community_server_id__llm_config__provider__usage_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/monitored-channels": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Monitored Channels
         * @description List monitored channel configurations for a specific community server.
         *
         *     Requires the community_server_id parameter and user must be an admin or moderator
         *     of that community server to view its monitored channels.
         *
         *     Returns paginated results filtered by community server and optionally by enabled status.
         */
        get: operations["list_monitored_channels_api_v1_monitored_channels_get"];
        put?: never;
        /**
         * Create Monitored Channel
         * @description Create a new monitored channel configuration.
         *
         *     Requires user to be an admin or moderator of the community server.
         *     Returns 409 if channel is already monitored.
         *     Returns 403 if user is not authorized to manage this community server.
         */
        post: operations["create_monitored_channel_api_v1_monitored_channels_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/monitored-channels/{channel_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Monitored Channel
         * @description Get configuration for a specific monitored channel.
         *
         *     Requires user to be an admin or moderator of the community server that owns the channel.
         *     Returns 404 if the channel is not monitored.
         *     Returns 403 if the user is not authorized to access this channel.
         */
        get: operations["get_monitored_channel_api_v1_monitored_channels__channel_id__get"];
        put?: never;
        post?: never;
        /**
         * Delete Monitored Channel
         * @description Remove a channel from monitoring.
         *
         *     Requires user to be an admin or moderator of the community server that owns the channel.
         *     Returns 404 if channel is not monitored.
         *     Returns 403 if user is not authorized to manage this channel.
         */
        delete: operations["delete_monitored_channel_api_v1_monitored_channels__channel_id__delete"];
        options?: never;
        head?: never;
        /**
         * Update Monitored Channel
         * @description Update configuration for a monitored channel.
         *
         *     Requires user to be an admin or moderator of the community server that owns the channel.
         *     Only provided fields are updated.
         *     Returns 404 if channel is not monitored.
         *     Returns 403 if user is not authorized to manage this channel.
         */
        patch: operations["update_monitored_channel_api_v1_monitored_channels__channel_id__patch"];
        trace?: never;
    };
    "/api/v1/embeddings/similarity-search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Similarity Search
         * @description Search for similar fact-check items using semantic similarity.
         *
         *     Generates an embedding for the input text using the community server's
         *     OpenAI API key, then performs cosine similarity search against the
         *     fact_check_items table using pgvector.
         *
         *     **Authorization:**
         *     - User must be an active member of the specified community server
         *     - Banned users are rejected with 403 Forbidden
         *     - External users without membership are rejected with 403 Forbidden
         *     - Prevents cost abuse by verifying community membership before API calls
         *
         *     **Process:**
         *     1. Verifies user is authorized member of community server
         *     2. Validates community server has OpenAI configuration
         *     3. Generates embedding using text-embedding-3-small (1536 dimensions)
         *     4. Queries fact_check_items table with pgvector cosine similarity
         *     5. Filters by dataset_tags (e.g., 'snopes', 'politifact')
         *     6. Returns top matches above similarity threshold
         *
         *     **Performance:**
         *     - Embedding generation: ~100-200ms (cached for 1 hour)
         *     - Similarity search: ~10-50ms (with pgvector indexing)
         *
         *     **Rate Limiting:**
         *     - Per-user rate limit: 100 requests/hour
         *     - Per-community rate limits: Based on configured LLM usage limits
         *     - OpenAI API rate limits: Automatic detection with retry guidance
         *
         *     **Audit Logging:**
         *     - All requests logged with user_id, profile_id, and community_server_id
         *     - Community role logged for authorization tracking
         *     - Cost attribution tracked per community server
         *
         *     Args:
         *         request: FastAPI request object (required by SlowAPI rate limiter)
         *         search_request: Similarity search request with text and parameters
         *         current_user: Authenticated user or API key
         *         db: Database session
         *         embedding_service: Embedding service instance
         *         usage_tracker: LLM usage tracker instance
         *
         *     Returns:
         *         List of matching fact-check items with similarity scores
         *
         *     Raises:
         *         400: Invalid request parameters
         *         403: User not authorized (not a member, banned, or inactive)
         *         404: Community server or OpenAI configuration not found
         *         429: Rate limit exceeded (per-user, per-community, or OpenAI API)
         *         500: Internal server error
         */
        post: operations["similarity_search_api_v1_embeddings_similarity_search_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/previously-seen/check": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Check Previously Seen
         * @description Check if a message has been seen before and get action recommendations.
         *
         *     This endpoint:
         *     1. Generates an embedding for the message text
         *     2. Searches for similar previously seen messages
         *     3. Resolves thresholds (channel override or global config)
         *     4. Returns action recommendations (auto-publish/auto-request)
         *
         *     Auto-publish (default 0.9): High similarity - automatically reply with existing note
         *     Auto-request (default 0.75): Moderate similarity - trigger auto-request for new note
         */
        post: operations["check_previously_seen_api_v1_previously_seen_check_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/health": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Health Check
         * @description Comprehensive health check that checks all registered components.
         */
        get: operations["health_check_health_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/health/live": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Liveness Check
         * @description Kubernetes liveness probe endpoint.
         */
        get: operations["liveness_check_health_live_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/health/ready": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Readiness Check
         * @description Kubernetes readiness probe endpoint.
         */
        get: operations["readiness_check_health_ready_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/health/distributed": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Distributed Health Check
         * @description Get aggregated health status across all instances.
         */
        get: operations["distributed_health_check_health_distributed_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/health/instances": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Instances Health Check
         * @description Get health status of all instances.
         */
        get: operations["instances_health_check_health_instances_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/health/instances/{instance_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Instance Health Check
         * @description Get health status of a specific instance.
         */
        get: operations["instance_health_check_health_instances__instance_id__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/health/simple": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Simple Health Check
         * @description Simple health check that returns basic status without checking components.
         */
        get: operations["simple_health_check_health_simple_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/health/redis": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Redis Health */
        get: operations["redis_health_health_redis_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/health/nats": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Nats Health */
        get: operations["nats_health_health_nats_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/health/detailed": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Detailed Health */
        get: operations["detailed_health_health_detailed_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/health/circuit-breakers": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Circuit Breakers Status */
        get: operations["circuit_breakers_status_health_circuit_breakers_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/metrics": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Metrics */
        get: operations["metrics_metrics_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        /** APIKeyCreate */
        APIKeyCreate: {
            /** Name */
            name: string;
            /** Expires In Days */
            expires_in_days?: number | null;
        };
        /** APIKeyResponse */
        APIKeyResponse: {
            /**
             * Id
             * Format: uuid
             */
            id: string;
            /** Name */
            name: string;
            /** Key */
            key: string;
            /**
             * Created At
             * Format: date-time
             */
            created_at: string;
            /** Expires At */
            expires_at: string | null;
            /** Last Used At */
            last_used_at: string | null;
        };
        /**
         * AddCommunityAdminRequest
         * @description Request schema for adding a community admin.
         */
        AddCommunityAdminRequest: {
            /**
             * User Discord Id
             * @description Discord ID of the user to promote to admin
             */
            user_discord_id: string;
            /**
             * Username
             * @description Discord username (for auto-creating profile if user doesn't exist)
             */
            username?: string | null;
            /**
             * Display Name
             * @description Display name (for auto-creating profile if user doesn't exist)
             */
            display_name?: string | null;
            /**
             * Avatar Url
             * @description Avatar URL (for auto-creating profile if user doesn't exist)
             */
            avatar_url?: string | null;
        };
        /**
         * AdminSource
         * @description Source of admin privileges.
         * @enum {string}
         */
        AdminSource: "opennotes_platform" | "community_role" | "discord_manage_server";
        /**
         * AdminStatusUpdateAttributes
         * @description Attributes for admin status update request.
         */
        AdminStatusUpdateAttributes: {
            /** Is Opennotes Admin */
            is_opennotes_admin: boolean;
        };
        /**
         * AdminStatusUpdateData
         * @description JSON:API data object for admin status update request.
         */
        AdminStatusUpdateData: {
            /**
             * Type
             * @default admin-status
             * @constant
             */
            type: "admin-status";
            /** Id */
            id: string;
            attributes: components["schemas"]["AdminStatusUpdateAttributes"];
        };
        /**
         * AdminStatusUpdateRequest
         * @description JSON:API request for updating admin status.
         */
        AdminStatusUpdateRequest: {
            data: components["schemas"]["AdminStatusUpdateData"];
        };
        /** AuditLogResponse */
        AuditLogResponse: {
            /**
             * Id
             * Format: uuid
             */
            id: string;
            /** User Id */
            user_id: string | null;
            /** Action */
            action: string;
            /** Resource */
            resource: string;
            /** Resource Id */
            resource_id: string | null;
            /** Details */
            details: {
                [key: string]: unknown;
            } | null;
            /** Ip Address */
            ip_address: string | null;
            /** User Agent */
            user_agent: string | null;
            /**
             * Created At
             * Format: date-time
             */
            created_at: string;
        };
        /**
         * AuthProvider
         * @description Supported authentication providers.
         * @enum {string}
         */
        AuthProvider: "discord" | "github" | "email";
        /**
         * BatchScoreJSONAPIRequest
         * @description JSON:API request body for batch scores.
         */
        BatchScoreJSONAPIRequest: {
            data: components["schemas"]["BatchScoreRequestData"];
        };
        /** BatchScoreRequest */
        BatchScoreRequest: {
            /**
             * Note Ids
             * @description List of note IDs to retrieve scores for
             */
            note_ids: string[];
        };
        /**
         * BatchScoreRequestAttributes
         * @description Attributes for batch score request via JSON:API.
         */
        BatchScoreRequestAttributes: {
            /**
             * Note Ids
             * @description List of note IDs to retrieve scores for
             */
            note_ids: string[];
        };
        /**
         * BatchScoreRequestData
         * @description JSON:API data object for batch score request.
         */
        BatchScoreRequestData: {
            /**
             * Type
             * @description Resource type must be 'batch-score-requests'
             * @constant
             */
            type: "batch-score-requests";
            attributes: components["schemas"]["BatchScoreRequestAttributes"];
        };
        /** BatchScoreResponse */
        BatchScoreResponse: {
            /**
             * Scores
             * @description Map of note IDs to their score responses
             */
            scores: {
                [key: string]: components["schemas"]["NoteScoreResponse"];
            };
            /**
             * Not Found
             * @description List of note IDs that were not found
             */
            not_found?: string[];
            /**
             * Total Requested
             * @description Total number of note IDs requested
             */
            total_requested: number;
            /**
             * Total Found
             * @description Total number of scores successfully retrieved
             */
            total_found: number;
        };
        /** Body_login_api_v1_auth_login_post */
        Body_login_api_v1_auth_login_post: {
            /** Grant Type */
            grant_type?: string | null;
            /** Username */
            username: string;
            /**
             * Password
             * Format: password
             */
            password: string;
            /**
             * Scope
             * @default
             */
            scope: string;
            /** Client Id */
            client_id?: string | null;
            /**
             * Client Secret
             * Format: password
             */
            client_secret?: string | null;
        };
        /** Body_login_email_api_v1_profile_auth_login_email_post */
        Body_login_email_api_v1_profile_auth_login_email_post: {
            /** Grant Type */
            grant_type?: string | null;
            /** Username */
            username: string;
            /**
             * Password
             * Format: password
             */
            password: string;
            /**
             * Scope
             * @default
             */
            scope: string;
            /** Client Id */
            client_id?: string | null;
            /**
             * Client Secret
             * Format: password
             */
            client_secret?: string | null;
        };
        /**
         * CommunityAdminResponse
         * @description Response schema for community admin information.
         */
        CommunityAdminResponse: {
            /**
             * Profile Id
             * Format: uuid
             * @description User profile identifier
             */
            profile_id: string;
            /**
             * Display Name
             * @description User's display name
             */
            display_name: string;
            /**
             * Avatar Url
             * @description URL to user's avatar image
             */
            avatar_url?: string | null;
            /**
             * Discord Id
             * @description User's Discord ID
             */
            discord_id: string;
            /**
             * Admin Sources
             * @description Sources of admin privileges (can have multiple)
             */
            admin_sources: components["schemas"]["AdminSource"][];
            /**
             * Is Opennotes Admin
             * @description Whether user is an Open Notes platform admin
             * @default false
             */
            is_opennotes_admin: boolean;
            /**
             * Community Role
             * @description User's role in the community
             * @default member
             */
            community_role: string;
            /**
             * Joined At
             * Format: date-time
             * @description When the user joined the community
             */
            joined_at: string;
        };
        /** CommunityConfigResponse */
        CommunityConfigResponse: {
            /**
             * Community Server Id
             * Format: uuid
             */
            community_server_id: string;
            /**
             * Config
             * @description Community server configuration key-value pairs
             */
            config?: {
                [key: string]: string;
            };
        };
        /**
         * CommunityMemberResponse
         * @description API response schema for community membership with nested profile.
         */
        "CommunityMemberResponse-Input": {
            /**
             * Created At
             * Format: date-time
             */
            created_at: string;
            /** Updated At */
            updated_at?: string | null;
            /**
             * Community Id
             * Format: uuid
             * @description Community identifier
             */
            community_id: string;
            /**
             * Is External
             * @description True for external participants, False for internal members
             * @default false
             */
            is_external: boolean;
            /**
             * @description Member role in the community
             * @default member
             */
            role: components["schemas"]["CommunityRole"];
            /**
             * Permissions
             * @description Role-specific permissions (JSON object). Kept as dict[str, Any] - permission structures vary by community platform (Discord roles, Reddit mod powers, etc.)
             */
            permissions?: {
                [key: string]: unknown;
            } | null;
            /**
             * Invitation Reason
             * @description Reason/context for invitation
             */
            invitation_reason?: string | null;
            /**
             * Id
             * Format: uuid
             * @description Unique membership identifier
             */
            id: string;
            /**
             * Profile Id
             * Format: uuid
             * @description User profile identifier
             */
            profile_id: string;
            /**
             * Reputation In Community
             * @description Community-specific reputation
             */
            reputation_in_community?: number | null;
            /**
             * Joined At
             * Format: date-time
             * @description When the user joined
             */
            joined_at: string;
            /**
             * Invited By
             * @description Profile ID of the user who invited this member
             */
            invited_by?: string | null;
            /**
             * Is Active
             * @description Whether membership is active
             * @default true
             */
            is_active: boolean;
            /**
             * Banned At
             * @description Ban timestamp
             */
            banned_at?: string | null;
            /**
             * Banned Reason
             * @description Reason for ban
             */
            banned_reason?: string | null;
            /** @description Associated user profile */
            profile?: components["schemas"]["UserProfileResponse-Input"] | null;
            /** @description Profile of the user who invited this member */
            inviter?: components["schemas"]["UserProfileResponse-Input"] | null;
        };
        /**
         * CommunityMemberResponse
         * @description API response schema for community membership with nested profile.
         */
        "CommunityMemberResponse-Output": {
            /** Created At */
            created_at: string;
            /** Updated At */
            updated_at?: string | null;
            /**
             * Community Id
             * Format: uuid
             * @description Community identifier
             */
            community_id: string;
            /**
             * Is External
             * @description True for external participants, False for internal members
             * @default false
             */
            is_external: boolean;
            /**
             * @description Member role in the community
             * @default member
             */
            role: components["schemas"]["CommunityRole"];
            /**
             * Permissions
             * @description Role-specific permissions (JSON object). Kept as dict[str, Any] - permission structures vary by community platform (Discord roles, Reddit mod powers, etc.)
             */
            permissions?: {
                [key: string]: unknown;
            } | null;
            /**
             * Invitation Reason
             * @description Reason/context for invitation
             */
            invitation_reason?: string | null;
            /**
             * Id
             * Format: uuid
             * @description Unique membership identifier
             */
            id: string;
            /**
             * Profile Id
             * Format: uuid
             * @description User profile identifier
             */
            profile_id: string;
            /**
             * Reputation In Community
             * @description Community-specific reputation
             */
            reputation_in_community?: number | null;
            /**
             * Joined At
             * Format: date-time
             * @description When the user joined
             */
            joined_at: string;
            /**
             * Invited By
             * @description Profile ID of the user who invited this member
             */
            invited_by?: string | null;
            /**
             * Is Active
             * @description Whether membership is active
             * @default true
             */
            is_active: boolean;
            /**
             * Banned At
             * @description Ban timestamp
             */
            banned_at?: string | null;
            /**
             * Banned Reason
             * @description Reason for ban
             */
            banned_reason?: string | null;
            /** @description Associated user profile */
            profile?: components["schemas"]["UserProfileResponse-Output"] | null;
            /** @description Profile of the user who invited this member */
            inviter?: components["schemas"]["UserProfileResponse-Output"] | null;
        };
        /**
         * CommunityRole
         * @description Community membership roles.
         * @enum {string}
         */
        CommunityRole: "admin" | "moderator" | "member";
        /**
         * CommunityServerLookupResponse
         * @description Response model for community server lookup.
         */
        CommunityServerLookupResponse: {
            /**
             * Id
             * Format: uuid
             * @description Internal community server UUID
             */
            id: string;
            /**
             * Platform
             * @description Platform type (e.g., 'discord')
             */
            platform: string;
            /**
             * Platform Id
             * @description Platform-specific ID (e.g., Discord guild ID)
             */
            platform_id: string;
            /**
             * Name
             * @description Community server name
             */
            name: string;
            /**
             * Is Active
             * @description Whether the community server is active
             */
            is_active: boolean;
        };
        /**
         * DataConfidence
         * @enum {string}
         */
        DataConfidence: "none" | "low" | "medium" | "high" | "very_high";
        /**
         * DiscordOAuthInitResponse
         * @description Response schema for Discord OAuth2 flow initialization.
         */
        DiscordOAuthInitResponse: {
            /**
             * Authorization Url
             * @description Discord OAuth2 authorization URL to redirect user to
             */
            authorization_url: string;
            /**
             * State
             * @description OAuth2 state parameter for CSRF protection (store for callback validation)
             */
            state: string;
        };
        /**
         * DiscordOAuthLoginRequest
         * @description Request schema for Discord OAuth2 login.
         */
        DiscordOAuthLoginRequest: {
            /**
             * Code
             * @description OAuth2 authorization code from Discord
             */
            code: string;
            /**
             * State
             * @description OAuth2 state parameter for CSRF protection (must match state from init)
             */
            state: string;
        };
        /**
         * DiscordOAuthRegisterRequest
         * @description Request schema for Discord OAuth2 registration.
         */
        DiscordOAuthRegisterRequest: {
            /**
             * Code
             * @description OAuth2 authorization code from Discord
             */
            code: string;
            /**
             * State
             * @description OAuth2 state parameter for CSRF protection (must match state from init)
             */
            state: string;
            /**
             * Display Name
             * @description User's desired display name
             */
            display_name: string;
            /**
             * Avatar Url
             * @description URL to user's avatar image (optional override)
             */
            avatar_url?: string | null;
        };
        /** DuplicateCheckResponse */
        DuplicateCheckResponse: {
            /** Exists */
            exists: boolean;
            /** Note Publisher Post Id */
            note_publisher_post_id?: string | null;
        };
        /** EnrollmentData */
        EnrollmentData: {
            /** Participantid */
            participantId: string;
            /** Enrollmentstate */
            enrollmentState: string;
            /** Successfulratingneededtoearnin */
            successfulRatingNeededToEarnIn: number;
            /** Timestampoflaststatechange */
            timestampOfLastStateChange: number;
        };
        /**
         * FactCheckMatch
         * @description Single fact-check similarity match result.
         */
        FactCheckMatch: {
            /**
             * Id
             * Format: uuid
             * @description Fact-check item UUID
             */
            id: string;
            /**
             * Dataset Name
             * @description Source dataset (e.g., 'snopes')
             */
            dataset_name: string;
            /**
             * Dataset Tags
             * @description Dataset tags
             */
            dataset_tags: string[];
            /**
             * Title
             * @description Fact-check article title
             */
            title: string;
            /**
             * Content
             * @description Fact-check content
             */
            content: string;
            /**
             * Summary
             * @description Brief summary
             */
            summary?: string | null;
            /**
             * Rating
             * @description Fact-check verdict
             */
            rating?: string | null;
            /**
             * Source Url
             * @description URL to original article
             */
            source_url?: string | null;
            /**
             * Published Date
             * @description Publication date
             */
            published_date?: string | null;
            /**
             * Author
             * @description Author name
             */
            author?: string | null;
            /**
             * Embedding Provider
             * @description LLM provider used for embedding (e.g., 'openai')
             */
            embedding_provider?: string | null;
            /**
             * Embedding Model
             * @description Model name used for embedding (e.g., 'text-embedding-3-small')
             */
            embedding_model?: string | null;
            /**
             * Similarity Score
             * @description Cosine similarity score (0.0-1.0)
             */
            similarity_score: number;
        };
        /** HTTPValidationError */
        HTTPValidationError: {
            /** Detail */
            detail?: components["schemas"]["ValidationError"][];
        };
        /** HealthCheckResponse */
        HealthCheckResponse: {
            /**
             * Status
             * @description Overall system status
             */
            status: string;
            /**
             * Timestamp
             * Format: date-time
             */
            timestamp?: string;
            /**
             * Version
             * @description API version
             */
            version: string;
            /**
             * Environment
             * @description Environment name
             */
            environment?: string | null;
            /**
             * Services
             * @description Individual service statuses
             */
            services?: {
                [key: string]: components["schemas"]["ServiceStatus"];
            };
            /**
             * Components
             * @description Component statuses (alias for services)
             */
            components?: {
                [key: string]: components["schemas"]["ServiceStatus"];
            } | null;
        };
        /**
         * HelpfulnessLevel
         * @enum {string}
         */
        HelpfulnessLevel: "HELPFUL" | "SOMEWHAT_HELPFUL" | "NOT_HELPFUL";
        /**
         * IdentityCreateAttributes
         * @description Attributes for identity create request.
         */
        IdentityCreateAttributes: {
            /** Provider */
            provider: string;
            /** Provider User Id */
            provider_user_id: string;
            /** Credentials */
            credentials?: {
                [key: string]: unknown;
            } | null;
        };
        /**
         * IdentityCreateData
         * @description JSON:API data object for identity create request.
         */
        IdentityCreateData: {
            /**
             * Type
             * @default identities
             * @constant
             */
            type: "identities";
            attributes: components["schemas"]["IdentityCreateAttributes"];
        };
        /**
         * IdentityCreateRequest
         * @description JSON:API request for creating an identity.
         */
        IdentityCreateRequest: {
            data: components["schemas"]["IdentityCreateData"];
        };
        /**
         * LLMConfigCreate
         * @description Schema for creating a new LLM configuration.
         */
        LLMConfigCreate: {
            /**
             * Provider
             * @enum {string}
             */
            provider: "openai" | "anthropic" | "google" | "cohere" | "custom";
            /**
             * Api Key
             * @description API key for the LLM provider
             */
            api_key: string;
            /**
             * Enabled
             * @description Whether this configuration is enabled
             * @default true
             */
            enabled: boolean;
            /**
             * Settings
             * @description Provider-specific settings (model, temperature, etc.). Kept as dict[str, Any] - each LLM provider has different configuration options and parameters.
             */
            settings?: {
                [key: string]: unknown;
            };
            /**
             * Daily Request Limit
             * @description Maximum daily API requests (None = unlimited)
             */
            daily_request_limit?: number | null;
            /**
             * Monthly Request Limit
             * @description Maximum monthly API requests (None = unlimited)
             */
            monthly_request_limit?: number | null;
            /**
             * Daily Token Limit
             * @description Maximum daily tokens (None = unlimited)
             */
            daily_token_limit?: number | null;
            /**
             * Monthly Token Limit
             * @description Maximum monthly tokens (None = unlimited)
             */
            monthly_token_limit?: number | null;
            /**
             * Daily Spend Limit
             * @description Maximum daily spending in USD (None = unlimited)
             */
            daily_spend_limit?: number | null;
            /**
             * Monthly Spend Limit
             * @description Maximum monthly spending in USD (None = unlimited)
             */
            monthly_spend_limit?: number | null;
        };
        /**
         * LLMConfigResponse
         * @description Schema for LLM configuration response (excludes full API key).
         */
        LLMConfigResponse: {
            /**
             * Id
             * Format: uuid
             */
            id: string;
            /**
             * Community Server Id
             * Format: uuid
             */
            community_server_id: string;
            /** Provider */
            provider: string;
            /**
             * Api Key Preview
             * @description Last 4 characters of API key
             */
            api_key_preview: string;
            /** Enabled */
            enabled: boolean;
            /** Settings */
            settings: {
                [key: string]: unknown;
            };
            /** Daily Request Limit */
            daily_request_limit: number | null;
            /** Monthly Request Limit */
            monthly_request_limit: number | null;
            /** Daily Token Limit */
            daily_token_limit: number | null;
            /** Monthly Token Limit */
            monthly_token_limit: number | null;
            /** Daily Spend Limit */
            daily_spend_limit: number | null;
            /** Monthly Spend Limit */
            monthly_spend_limit: number | null;
            /** Current Daily Requests */
            current_daily_requests: number;
            /** Current Monthly Requests */
            current_monthly_requests: number;
            /** Current Daily Tokens */
            current_daily_tokens: number;
            /** Current Monthly Tokens */
            current_monthly_tokens: number;
            /** Current Daily Spend */
            current_daily_spend: number;
            /** Current Monthly Spend */
            current_monthly_spend: number;
            /** Last Daily Reset */
            last_daily_reset: string | null;
            /** Last Monthly Reset */
            last_monthly_reset: string | null;
            /**
             * Created At
             * Format: date-time
             */
            created_at: string;
            /**
             * Updated At
             * Format: date-time
             */
            updated_at: string;
            /** Created By */
            created_by: string | null;
        };
        /**
         * LLMConfigTestRequest
         * @description Schema for testing an LLM configuration.
         */
        LLMConfigTestRequest: {
            /**
             * Provider
             * @enum {string}
             */
            provider: "openai" | "anthropic" | "google" | "cohere" | "custom";
            /** Api Key */
            api_key: string;
            /** Settings */
            settings?: {
                [key: string]: unknown;
            };
        };
        /** LLMConfigTestResponse */
        LLMConfigTestResponse: {
            /** Valid */
            valid: boolean;
            /** Error Message */
            error_message?: string | null;
        };
        /**
         * LLMConfigUpdate
         * @description Schema for updating an existing LLM configuration.
         */
        LLMConfigUpdate: {
            /** Api Key */
            api_key?: string | null;
            /** Enabled */
            enabled?: boolean | null;
            /** Settings */
            settings?: {
                [key: string]: unknown;
            } | null;
            /** Daily Request Limit */
            daily_request_limit?: number | null;
            /** Monthly Request Limit */
            monthly_request_limit?: number | null;
            /** Daily Token Limit */
            daily_token_limit?: number | null;
            /** Monthly Token Limit */
            monthly_token_limit?: number | null;
            /** Daily Spend Limit */
            daily_spend_limit?: number | null;
            /** Monthly Spend Limit */
            monthly_spend_limit?: number | null;
        };
        /** LLMUsageStatsResponse */
        LLMUsageStatsResponse: {
            /** Provider */
            provider: string;
            /** Daily Requests */
            daily_requests: {
                [key: string]: unknown;
            };
            /** Monthly Requests */
            monthly_requests: {
                [key: string]: unknown;
            };
            /** Daily Tokens */
            daily_tokens: {
                [key: string]: unknown;
            };
            /** Monthly Tokens */
            monthly_tokens: {
                [key: string]: unknown;
            };
            /** Daily Spend */
            daily_spend: {
                [key: string]: unknown;
            };
            /** Monthly Spend */
            monthly_spend: {
                [key: string]: unknown;
            };
            /** Last Daily Reset */
            last_daily_reset: string | null;
            /** Last Monthly Reset */
            last_monthly_reset: string | null;
        };
        /** LastPostResponse */
        LastPostResponse: {
            /** Posted At */
            posted_at: string;
            /** Note Id */
            note_id: string;
            /** Channel Id */
            channel_id: string;
        };
        /**
         * MonitoredChannelCreate
         * @description Schema for creating a monitored channel configuration.
         */
        MonitoredChannelCreate: {
            /**
             * Community Server Id
             * @description Discord server/guild ID
             */
            community_server_id: string;
            /**
             * Channel Id
             * @description Discord channel ID
             */
            channel_id: string;
            /**
             * Enabled
             * @description Whether monitoring is active
             * @default true
             */
            enabled: boolean;
            /**
             * Similarity Threshold
             * @description Minimum similarity score (0.0-1.0) for fact-check matches
             */
            similarity_threshold?: number;
            /**
             * Dataset Tags
             * @description Dataset tags to check against (e.g., ['snopes', 'politifact'])
             */
            dataset_tags?: string[];
            /**
             * Previously Seen Autopublish Threshold
             * @description Per-channel override for auto-publish threshold (NULL = use global config default)
             */
            previously_seen_autopublish_threshold?: number | null;
            /**
             * Previously Seen Autorequest Threshold
             * @description Per-channel override for auto-request threshold (NULL = use global config default)
             */
            previously_seen_autorequest_threshold?: number | null;
            /**
             * Updated By
             * @description Discord user ID of admin creating config
             */
            updated_by?: string | null;
        };
        /**
         * MonitoredChannelCreateAttributes
         * @description Attributes for creating a monitored channel via JSON:API.
         */
        MonitoredChannelCreateAttributes: {
            /**
             * Community Server Id
             * @description Discord server/guild ID (platform ID)
             */
            community_server_id: string;
            /**
             * Channel Id
             * @description Discord channel ID
             */
            channel_id: string;
            /**
             * Enabled
             * @description Whether monitoring is active
             * @default true
             */
            enabled: boolean;
            /**
             * Similarity Threshold
             * @description Minimum similarity score (0.0-1.0) for matches
             */
            similarity_threshold?: number;
            /**
             * Dataset Tags
             * @description Dataset tags to check against
             */
            dataset_tags?: string[];
            /**
             * Previously Seen Autopublish Threshold
             * @description Per-channel override for auto-publish threshold
             */
            previously_seen_autopublish_threshold?: number | null;
            /**
             * Previously Seen Autorequest Threshold
             * @description Per-channel override for auto-request threshold
             */
            previously_seen_autorequest_threshold?: number | null;
            /**
             * Updated By
             * @description Discord user ID of admin creating config
             */
            updated_by?: string | null;
        };
        /**
         * MonitoredChannelCreateData
         * @description JSON:API data object for monitored channel creation.
         */
        MonitoredChannelCreateData: {
            /**
             * Type
             * @description Resource type must be 'monitored-channels'
             * @constant
             */
            type: "monitored-channels";
            attributes: components["schemas"]["MonitoredChannelCreateAttributes"];
        };
        /**
         * MonitoredChannelCreateRequest
         * @description JSON:API request body for creating a monitored channel.
         */
        MonitoredChannelCreateRequest: {
            data: components["schemas"]["MonitoredChannelCreateData"];
        };
        /**
         * MonitoredChannelListResponse
         * @description Schema for paginated list of monitored channels.
         */
        MonitoredChannelListResponse: {
            /**
             * Channels
             * @description List of monitored channels
             */
            channels: components["schemas"]["MonitoredChannelResponse"][];
            /**
             * Total
             * @description Total count of channels
             */
            total: number;
            /**
             * Page
             * @description Current page number
             * @default 1
             */
            page: number;
            /**
             * Size
             * @description Items per page
             * @default 20
             */
            size: number;
        };
        /**
         * MonitoredChannelResponse
         * @description Schema for monitored channel configuration responses.
         */
        MonitoredChannelResponse: {
            /**
             * Community Server Id
             * @description Discord server/guild ID
             */
            community_server_id: string;
            /**
             * Channel Id
             * @description Discord channel ID
             */
            channel_id: string;
            /**
             * Enabled
             * @description Whether monitoring is active
             * @default true
             */
            enabled: boolean;
            /**
             * Similarity Threshold
             * @description Minimum similarity score (0.0-1.0) for fact-check matches
             */
            similarity_threshold?: number;
            /**
             * Dataset Tags
             * @description Dataset tags to check against (e.g., ['snopes', 'politifact'])
             */
            dataset_tags?: string[];
            /**
             * Previously Seen Autopublish Threshold
             * @description Per-channel override for auto-publish threshold (NULL = use global config default)
             */
            previously_seen_autopublish_threshold?: number | null;
            /**
             * Previously Seen Autorequest Threshold
             * @description Per-channel override for auto-request threshold (NULL = use global config default)
             */
            previously_seen_autorequest_threshold?: number | null;
            /**
             * Id
             * Format: uuid
             * @description Unique identifier
             */
            id: string;
            /**
             * Created At
             * Format: date-time
             * @description When monitoring was configured
             */
            created_at: string;
            /**
             * Updated At
             * Format: date-time
             * @description Last configuration update
             */
            updated_at: string;
            /**
             * Updated By
             * @description Discord user ID of last admin to update
             */
            updated_by?: string | null;
        };
        /**
         * MonitoredChannelUpdate
         * @description Schema for updating a monitored channel configuration.
         */
        MonitoredChannelUpdate: {
            /**
             * Enabled
             * @description Whether monitoring is active
             */
            enabled?: boolean | null;
            /**
             * Similarity Threshold
             * @description Minimum similarity score (0.0-1.0) for fact-check matches
             */
            similarity_threshold?: number | null;
            /**
             * Dataset Tags
             * @description Dataset tags to check against (e.g., ['snopes', 'politifact'])
             */
            dataset_tags?: string[] | null;
            /**
             * Previously Seen Autopublish Threshold
             * @description Per-channel override for auto-publish threshold (NULL = use global config default)
             */
            previously_seen_autopublish_threshold?: number | null;
            /**
             * Previously Seen Autorequest Threshold
             * @description Per-channel override for auto-request threshold (NULL = use global config default)
             */
            previously_seen_autorequest_threshold?: number | null;
            /**
             * Updated By
             * @description Discord user ID of admin updating config
             */
            updated_by?: string | null;
        };
        /**
         * MonitoredChannelUpdateAttributes
         * @description Attributes for updating a monitored channel via JSON:API.
         */
        MonitoredChannelUpdateAttributes: {
            /**
             * Enabled
             * @description Whether monitoring is active
             */
            enabled?: boolean | null;
            /**
             * Similarity Threshold
             * @description Minimum similarity score (0.0-1.0) for matches
             */
            similarity_threshold?: number | null;
            /**
             * Dataset Tags
             * @description Dataset tags to check against
             */
            dataset_tags?: string[] | null;
            /**
             * Previously Seen Autopublish Threshold
             * @description Per-channel override for auto-publish threshold
             */
            previously_seen_autopublish_threshold?: number | null;
            /**
             * Previously Seen Autorequest Threshold
             * @description Per-channel override for auto-request threshold
             */
            previously_seen_autorequest_threshold?: number | null;
            /**
             * Updated By
             * @description Discord user ID of admin updating config
             */
            updated_by?: string | null;
        };
        /**
         * MonitoredChannelUpdateData
         * @description JSON:API data object for monitored channel update.
         */
        MonitoredChannelUpdateData: {
            /**
             * Type
             * @description Resource type must be 'monitored-channels'
             * @constant
             */
            type: "monitored-channels";
            /**
             * Id
             * @description Monitored channel ID
             */
            id: string;
            attributes: components["schemas"]["MonitoredChannelUpdateAttributes"];
        };
        /**
         * MonitoredChannelUpdateRequest
         * @description JSON:API request body for updating a monitored channel.
         */
        MonitoredChannelUpdateRequest: {
            data: components["schemas"]["MonitoredChannelUpdateData"];
        };
        /** NextTierInfo */
        NextTierInfo: {
            /**
             * Tier
             * @description Name of the next tier
             */
            tier: string;
            /**
             * Notes Needed
             * @description Total notes needed to reach next tier
             */
            notes_needed: number;
            /**
             * Notes To Upgrade
             * @description Additional notes needed (negative means already exceeded)
             */
            notes_to_upgrade: number;
        };
        /**
         * NoteClassification
         * @enum {string}
         */
        NoteClassification: "NOT_MISLEADING" | "MISINFORMED_OR_POTENTIALLY_MISLEADING";
        /** NoteCreate */
        NoteCreate: {
            /**
             * Author Participant Id
             * @description Author's participant ID
             */
            author_participant_id: string;
            /**
             * Channel Id
             * @description Discord channel ID where the message is located
             */
            channel_id?: string | null;
            /**
             * Request Id
             * @description Request ID this note responds to
             */
            request_id?: string | null;
            /**
             * Summary
             * @description Note summary text
             */
            summary: string;
            /** @description Note classification */
            classification: components["schemas"]["NoteClassification"];
            /**
             * Community Server Id
             * Format: uuid
             * @description Community server ID (required)
             */
            community_server_id: string;
        };
        /**
         * NoteCreateAttributes
         * @description Attributes for creating a note via JSON:API.
         */
        NoteCreateAttributes: {
            /**
             * Summary
             * @description Note summary text
             */
            summary: string;
            /** @description Note classification */
            classification: components["schemas"]["NoteClassification"];
            /**
             * Community Server Id
             * Format: uuid
             * @description Community server ID
             */
            community_server_id: string;
            /**
             * Author Participant Id
             * @description Author's participant ID
             */
            author_participant_id: string;
            /**
             * Channel Id
             * @description Discord channel ID
             */
            channel_id?: string | null;
            /**
             * Request Id
             * @description Request ID this note responds to
             */
            request_id?: string | null;
        };
        /**
         * NoteCreateData
         * @description JSON:API data object for note creation.
         */
        NoteCreateData: {
            /**
             * Type
             * @description Resource type must be 'notes'
             * @constant
             */
            type: "notes";
            attributes: components["schemas"]["NoteCreateAttributes"];
        };
        /**
         * NoteCreateRequest
         * @description JSON:API request body for creating a note.
         */
        NoteCreateRequest: {
            data: components["schemas"]["NoteCreateData"];
        };
        /** NoteData */
        NoteData: {
            /** Noteid */
            noteId: number;
            /** Noteauthorparticipantid */
            noteAuthorParticipantId: string;
            /** Createdatmillis */
            createdAtMillis: number;
            /** Tweetid */
            tweetId: number;
            /** Summary */
            summary: string;
            /** Classification */
            classification: string;
        };
        /** NoteListResponse */
        NoteListResponse: {
            /** Notes */
            notes: components["schemas"]["NoteResponse"][];
            /** Total */
            total: number;
            /** Page */
            page: number;
            /** Size */
            size: number;
        };
        /**
         * NotePublisherConfigCreateAttributes
         * @description Attributes for creating a note publisher config via JSON:API.
         */
        NotePublisherConfigCreateAttributes: {
            /**
             * Community Server Id
             * @description Discord server/guild ID (platform ID)
             */
            community_server_id: string;
            /**
             * Channel Id
             * @description Discord channel ID (None for server-wide)
             */
            channel_id?: string | null;
            /**
             * Enabled
             * @description Whether auto-publishing is enabled
             * @default true
             */
            enabled: boolean;
            /**
             * Threshold
             * @description Score threshold for auto-publishing (0.0-1.0)
             */
            threshold?: number | null;
            /**
             * Updated By
             * @description Discord user ID of admin
             */
            updated_by?: string | null;
        };
        /**
         * NotePublisherConfigCreateData
         * @description JSON:API data object for config creation.
         */
        NotePublisherConfigCreateData: {
            /**
             * Type
             * @description Resource type must be 'note-publisher-configs'
             * @constant
             */
            type: "note-publisher-configs";
            attributes: components["schemas"]["NotePublisherConfigCreateAttributes"];
        };
        /**
         * NotePublisherConfigCreateRequest
         * @description JSON:API request body for creating a config.
         */
        NotePublisherConfigCreateRequest: {
            data: components["schemas"]["NotePublisherConfigCreateData"];
        };
        /** NotePublisherConfigRequest */
        NotePublisherConfigRequest: {
            /** Community Server Id */
            community_server_id: string;
            /** Channel Id */
            channel_id?: string | null;
            /** Enabled */
            enabled: boolean;
            /** Threshold */
            threshold?: number | null;
            /** Updated By */
            updated_by?: string | null;
        };
        /** NotePublisherConfigResponse */
        NotePublisherConfigResponse: {
            /** Id */
            id: string;
            /** Community Server Id */
            community_server_id: string;
            /** Channel Id */
            channel_id: string | null;
            /** Enabled */
            enabled: boolean;
            /** Threshold */
            threshold: number | null;
            /** Updated At */
            updated_at: string;
            /** Updated By */
            updated_by: string | null;
        };
        /**
         * NotePublisherConfigUpdateAttributes
         * @description Attributes for updating a note publisher config via JSON:API.
         */
        NotePublisherConfigUpdateAttributes: {
            /**
             * Enabled
             * @description Whether auto-publishing is enabled
             */
            enabled?: boolean | null;
            /**
             * Threshold
             * @description Score threshold for auto-publishing (0.0-1.0)
             */
            threshold?: number | null;
            /**
             * Updated By
             * @description Discord user ID of admin
             */
            updated_by?: string | null;
        };
        /**
         * NotePublisherConfigUpdateData
         * @description JSON:API data object for config update.
         */
        NotePublisherConfigUpdateData: {
            /**
             * Type
             * @description Resource type must be 'note-publisher-configs'
             * @constant
             */
            type: "note-publisher-configs";
            /**
             * Id
             * @description Config ID
             */
            id: string;
            attributes: components["schemas"]["NotePublisherConfigUpdateAttributes"];
        };
        /**
         * NotePublisherConfigUpdateRequest
         * @description JSON:API request body for updating a config.
         */
        NotePublisherConfigUpdateRequest: {
            data: components["schemas"]["NotePublisherConfigUpdateData"];
        };
        /**
         * NotePublisherPostCreateAttributes
         * @description Attributes for creating a note publisher post via JSON:API.
         */
        NotePublisherPostCreateAttributes: {
            /**
             * Note Id
             * @description UUID of the published note
             */
            note_id: string;
            /**
             * Original Message Id
             * @description Original Discord message ID
             */
            original_message_id: string;
            /**
             * Auto Post Message Id
             * @description Auto-posted Discord message ID
             */
            auto_post_message_id?: string | null;
            /**
             * Channel Id
             * @description Discord channel ID
             */
            channel_id: string;
            /**
             * Community Server Id
             * @description Discord server/guild ID (platform ID)
             */
            community_server_id: string;
            /**
             * Score At Post
             * @description Score at time of posting
             */
            score_at_post: number;
            /**
             * Confidence At Post
             * @description Confidence level at posting
             */
            confidence_at_post: string;
            /**
             * Success
             * @description Whether the post was successful
             */
            success: boolean;
            /**
             * Error Message
             * @description Error message if post failed
             */
            error_message?: string | null;
        };
        /**
         * NotePublisherPostCreateData
         * @description JSON:API data object for post creation.
         */
        NotePublisherPostCreateData: {
            /**
             * Type
             * @description Resource type must be 'note-publisher-posts'
             * @constant
             */
            type: "note-publisher-posts";
            attributes: components["schemas"]["NotePublisherPostCreateAttributes"];
        };
        /**
         * NotePublisherPostCreateRequest
         * @description JSON:API request body for creating a post record.
         */
        NotePublisherPostCreateRequest: {
            data: components["schemas"]["NotePublisherPostCreateData"];
        };
        /** NotePublisherRecordRequest */
        NotePublisherRecordRequest: {
            /**
             * Noteid
             * @description UUID of the published note
             */
            noteId: string;
            /** Originalmessageid */
            originalMessageId: string;
            /** Channelid */
            channelId: string;
            /** Guildid */
            guildId: string;
            /** Scoreatpost */
            scoreAtPost: number;
            /** Confidenceatpost */
            confidenceAtPost: string;
            /** Success */
            success: boolean;
            /** Errormessage */
            errorMessage?: string | null;
            /** Messageembedding */
            messageEmbedding?: number[] | null;
            /** Embeddingprovider */
            embeddingProvider?: string | null;
            /** Embeddingmodel */
            embeddingModel?: string | null;
        };
        /** NoteResponse */
        NoteResponse: {
            /** Created At */
            created_at: string;
            /** Updated At */
            updated_at?: string | null;
            /**
             * Author Participant Id
             * @description Author's participant ID
             */
            author_participant_id: string;
            /**
             * Channel Id
             * @description Discord channel ID where the message is located
             */
            channel_id?: string | null;
            /**
             * Request Id
             * @description Request ID this note responds to
             */
            request_id?: string | null;
            /**
             * Summary
             * @description Note summary text
             */
            summary: string;
            /** @description Note classification */
            classification: components["schemas"]["NoteClassification"];
            /**
             * Id
             * Format: uuid
             */
            id: string;
            /**
             * Community Server Id
             * Format: uuid
             */
            community_server_id: string;
            /** Helpfulness Score */
            helpfulness_score: number;
            status: components["schemas"]["NoteStatus"];
            /**
             * Force Published
             * @default false
             */
            force_published: boolean;
            /** Force Published By */
            force_published_by?: string | null;
            /** Force Published At */
            force_published_at?: string | null;
            /**
             * Ratings
             * @default []
             */
            ratings: components["schemas"]["RatingResponse"][];
            request?: components["schemas"]["RequestInfo"] | null;
            /**
             * Ratings Count
             * @description Compute ratings count from loaded ratings relationship.
             */
            readonly ratings_count: number;
        };
        /** NoteScoreResponse */
        NoteScoreResponse: {
            /**
             * Note Id
             * Format: uuid
             * @description Unique note identifier
             */
            note_id: string;
            /**
             * Score
             * @description Normalized score value (0.0-1.0)
             */
            score: number;
            /** @description Confidence level: no_data (0 ratings), provisional (<5 ratings), or standard (5+ ratings) */
            confidence: components["schemas"]["ScoreConfidence"];
            /**
             * Algorithm
             * @description Scoring algorithm used (e.g., 'bayesian_average_tier0', 'MFCoreScorer')
             */
            algorithm: string;
            /**
             * Rating Count
             * @description Number of ratings contributing to the score
             */
            rating_count: number;
            /**
             * Tier
             * @description Current scoring tier level (0-5)
             */
            tier: number;
            /**
             * Tier Name
             * @description Human-readable tier name (e.g., 'Minimal', 'Limited')
             */
            tier_name: string;
            /**
             * Calculated At
             * @description Timestamp when score was calculated (null if not yet calculated)
             */
            calculated_at?: string | null;
            /**
             * Content
             * @description Message content that the note was written about (from message archive)
             */
            content?: string | null;
        };
        /**
         * NoteStatus
         * @enum {string}
         */
        NoteStatus: "NEEDS_MORE_RATINGS" | "CURRENTLY_RATED_HELPFUL" | "CURRENTLY_RATED_NOT_HELPFUL";
        /** NoteSummaryStats */
        NoteSummaryStats: {
            /** Total Notes */
            total_notes: number;
            /** Helpful Notes */
            helpful_notes: number;
            /** Not Helpful Notes */
            not_helpful_notes: number;
            /** Pending Notes */
            pending_notes: number;
            /** Average Helpfulness Score */
            average_helpfulness_score: number;
        };
        /** NoteUpdate */
        NoteUpdate: {
            /** Summary */
            summary?: string | null;
            classification?: components["schemas"]["NoteClassification"] | null;
        };
        /**
         * NoteUpdateAttributes
         * @description Attributes for updating a note via JSON:API.
         */
        NoteUpdateAttributes: {
            /**
             * Summary
             * @description Updated note summary
             */
            summary?: string | null;
            /** @description Updated classification */
            classification?: components["schemas"]["NoteClassification"] | null;
        };
        /**
         * NoteUpdateData
         * @description JSON:API data object for note update.
         */
        NoteUpdateData: {
            /**
             * Type
             * @description Resource type must be 'notes'
             * @constant
             */
            type: "notes";
            /**
             * Id
             * @description Note ID being updated
             */
            id: string;
            attributes: components["schemas"]["NoteUpdateAttributes"];
        };
        /**
         * NoteUpdateRequest
         * @description JSON:API request body for updating a note.
         */
        NoteUpdateRequest: {
            data: components["schemas"]["NoteUpdateData"];
        };
        /** ParticipantStats */
        ParticipantStats: {
            /** Participant Id */
            participant_id: string;
            /** Notes Created */
            notes_created: number;
            /** Ratings Given */
            ratings_given: number;
            /** Average Helpfulness Received */
            average_helpfulness_received: number;
            top_classification?: components["schemas"]["NoteClassification"] | null;
        };
        /** PerformanceMetrics */
        PerformanceMetrics: {
            /**
             * Avg Scoring Time Ms
             * @description Average scoring time in milliseconds
             */
            avg_scoring_time_ms: number;
            /**
             * Last Scoring Time Ms
             * @description Last scoring operation time in milliseconds
             */
            last_scoring_time_ms?: number | null;
            /**
             * Scorer Success Rate
             * @description Success rate for scoring operations (0.0-1.0)
             */
            scorer_success_rate: number;
            /**
             * Total Scoring Operations
             * @description Total number of scoring operations performed
             * @default 0
             */
            total_scoring_operations: number;
            /**
             * Failed Scoring Operations
             * @description Number of failed scoring operations
             * @default 0
             */
            failed_scoring_operations: number;
        };
        /**
         * PreviouslySeenCheckAttributes
         * @description Attributes for checking previously seen messages via JSON:API.
         */
        PreviouslySeenCheckAttributes: {
            /**
             * Message Text
             * @description Message text to check
             */
            message_text: string;
            /**
             * Guild Id
             * @description Discord guild ID
             */
            guild_id: string;
            /**
             * Channel Id
             * @description Discord channel ID
             */
            channel_id: string;
        };
        /**
         * PreviouslySeenCheckData
         * @description JSON:API data object for previously seen message check.
         */
        PreviouslySeenCheckData: {
            /**
             * Type
             * @description Resource type must be 'previously-seen-check'
             * @constant
             */
            type: "previously-seen-check";
            attributes: components["schemas"]["PreviouslySeenCheckAttributes"];
        };
        /**
         * PreviouslySeenCheckResponse
         * @description Response with previously seen message matches and action recommendations.
         */
        PreviouslySeenCheckResponse: {
            /**
             * Shouldautopublish
             * @description Whether to auto-publish existing note
             */
            shouldAutoPublish: boolean;
            /**
             * Shouldautorequest
             * @description Whether to auto-request new note
             */
            shouldAutoRequest: boolean;
            /**
             * Autopublishthreshold
             * @description Threshold used for auto-publish decision
             */
            autopublishThreshold: number;
            /**
             * Autorequestthreshold
             * @description Threshold used for auto-request decision
             */
            autorequestThreshold: number;
            /**
             * Matches
             * @description Matching previously seen messages (ordered by similarity)
             */
            matches: components["schemas"]["PreviouslySeenMessageMatch"][];
            /** @description Best matching message if any */
            topMatch?: components["schemas"]["PreviouslySeenMessageMatch"] | null;
        };
        /**
         * PreviouslySeenMessageCreateAttributes
         * @description Attributes for creating a previously seen message via JSON:API.
         */
        PreviouslySeenMessageCreateAttributes: {
            /**
             * Community Server Id
             * @description Community server UUID
             */
            community_server_id: string;
            /**
             * Original Message Id
             * @description Platform-specific message ID
             */
            original_message_id: string;
            /**
             * Published Note Id
             * @description Note ID that was published for this message
             */
            published_note_id: string;
            /**
             * Embedding
             * @description Vector embedding for semantic similarity search (1536 dimensions)
             */
            embedding?: number[] | null;
            /**
             * Embedding Provider
             * @description LLM provider used for embedding generation
             */
            embedding_provider?: string | null;
            /**
             * Embedding Model
             * @description Model name used for embedding generation
             */
            embedding_model?: string | null;
            /**
             * Extra Metadata
             * @description Additional context metadata
             */
            extra_metadata?: {
                [key: string]: string | number | boolean | null;
            } | null;
        };
        /**
         * PreviouslySeenMessageCreateData
         * @description JSON:API data object for previously seen message creation.
         */
        PreviouslySeenMessageCreateData: {
            /**
             * Type
             * @description Resource type must be 'previously-seen-messages'
             * @constant
             */
            type: "previously-seen-messages";
            attributes: components["schemas"]["PreviouslySeenMessageCreateAttributes"];
        };
        /**
         * PreviouslySeenMessageCreateRequest
         * @description JSON:API request body for creating a previously seen message.
         */
        PreviouslySeenMessageCreateRequest: {
            data: components["schemas"]["PreviouslySeenMessageCreateData"];
        };
        /**
         * PreviouslySeenMessageMatch
         * @description Previously seen message with similarity score (used in search results).
         */
        PreviouslySeenMessageMatch: {
            /**
             * Id
             * Format: uuid
             * @description Unique identifier
             */
            id: string;
            /**
             * Community Server Id
             * Format: uuid
             * @description Community server UUID
             */
            community_server_id: string;
            /**
             * Original Message Id
             * @description Platform-specific message ID
             */
            original_message_id: string;
            /**
             * Published Note Id
             * Format: uuid
             * @description Note ID that was published
             */
            published_note_id: string;
            /**
             * Embedding Provider
             * @description LLM provider used
             */
            embedding_provider?: string | null;
            /**
             * Embedding Model
             * @description Model name used
             */
            embedding_model?: string | null;
            /**
             * Extra Metadata
             * @description Additional context metadata
             */
            extra_metadata?: {
                [key: string]: string | number | boolean | null;
            };
            /**
             * Created At
             * Format: date-time
             * @description When record was created
             */
            created_at: string;
            /**
             * Similarity Score
             * @description Cosine similarity score (0.0-1.0)
             */
            similarity_score: number;
        };
        /**
         * ProfileUpdateAttributes
         * @description Attributes for profile update request.
         */
        ProfileUpdateAttributes: {
            /** Display Name */
            display_name?: string | null;
            /** Avatar Url */
            avatar_url?: string | null;
            /** Bio */
            bio?: string | null;
        };
        /**
         * ProfileUpdateData
         * @description JSON:API data object for profile update request.
         */
        ProfileUpdateData: {
            /**
             * Type
             * @default profiles
             * @constant
             */
            type: "profiles";
            /** Id */
            id: string;
            attributes: components["schemas"]["ProfileUpdateAttributes"];
        };
        /**
         * ProfileUpdateRequest
         * @description JSON:API request for updating a profile.
         */
        ProfileUpdateRequest: {
            data: components["schemas"]["ProfileUpdateData"];
        };
        /**
         * RatingCreateAttributes
         * @description Attributes for creating a rating via JSON:API.
         */
        RatingCreateAttributes: {
            /**
             * Note Id
             * Format: uuid
             * @description Note ID to rate
             */
            note_id: string;
            /**
             * Rater Participant Id
             * @description Rater's participant ID
             */
            rater_participant_id: string;
            /** @description Rating level */
            helpfulness_level: components["schemas"]["HelpfulnessLevel"];
        };
        /**
         * RatingCreateData
         * @description JSON:API data object for rating creation.
         */
        RatingCreateData: {
            /**
             * Type
             * @description Resource type must be 'ratings'
             * @constant
             */
            type: "ratings";
            attributes: components["schemas"]["RatingCreateAttributes"];
        };
        /**
         * RatingCreateRequest
         * @description JSON:API request body for creating a rating.
         */
        RatingCreateRequest: {
            data: components["schemas"]["RatingCreateData"];
        };
        /** RatingData */
        RatingData: {
            /** Raterparticipantid */
            raterParticipantId: string;
            /** Noteid */
            noteId: number;
            /** Createdatmillis */
            createdAtMillis: number;
            /** Helpfulnesslevel */
            helpfulnessLevel: string;
        };
        /** RatingResponse */
        RatingResponse: {
            /** Created At */
            created_at: string;
            /** Updated At */
            updated_at?: string | null;
            /**
             * Note Id
             * Format: uuid
             * @description Note ID to rate
             */
            note_id: string;
            /** @description Rating level */
            helpfulness_level: components["schemas"]["HelpfulnessLevel"];
            /**
             * Id
             * Format: uuid
             */
            id: string;
            /** Rater Participant Id */
            rater_participant_id: string;
        };
        /** RatingThresholdsResponse */
        RatingThresholdsResponse: {
            /**
             * Min Ratings Needed
             * @description Minimum number of ratings before a note can receive CRH/CRNH status
             */
            min_ratings_needed: number;
            /**
             * Min Raters Per Note
             * @description Minimum number of unique raters required per note
             */
            min_raters_per_note: number;
        };
        /**
         * RatingUpdateAttributes
         * @description Attributes for updating a rating via JSON:API.
         */
        RatingUpdateAttributes: {
            /** @description Rating level */
            helpfulness_level: components["schemas"]["HelpfulnessLevel"];
        };
        /**
         * RatingUpdateData
         * @description JSON:API data object for rating update.
         */
        RatingUpdateData: {
            /**
             * Type
             * @description Resource type must be 'ratings'
             * @constant
             */
            type: "ratings";
            /**
             * Id
             * @description Rating ID
             */
            id: string;
            attributes: components["schemas"]["RatingUpdateAttributes"];
        };
        /**
         * RatingUpdateRequest
         * @description JSON:API request body for updating a rating.
         */
        RatingUpdateRequest: {
            data: components["schemas"]["RatingUpdateData"];
        };
        /**
         * RefreshTokenRequest
         * @description Request body for refresh token endpoint.
         */
        RefreshTokenRequest: {
            /**
             * Refresh Token
             * @description The refresh token to use for getting a new access token
             */
            refresh_token: string;
        };
        /**
         * RemoveCommunityAdminResponse
         * @description Response schema for admin removal.
         */
        RemoveCommunityAdminResponse: {
            /**
             * Success
             * @description Whether the operation succeeded
             */
            success: boolean;
            /**
             * Message
             * @description Human-readable result message
             */
            message: string;
            /**
             * Profile Id
             * Format: uuid
             * @description Profile ID of the affected user
             */
            profile_id: string;
            /**
             * Previous Role
             * @description User's previous role
             */
            previous_role: string;
            /**
             * New Role
             * @description User's new role
             */
            new_role: string;
        };
        /** RequestCreate */
        RequestCreate: {
            /**
             * Request Id
             * @description Unique request identifier
             */
            request_id: string;
            /**
             * Requested By
             * @description Requester's participant ID
             */
            requested_by: string;
            /**
             * Community Server Id
             * @description Community server ID (Discord guild ID, subreddit, etc.)
             */
            community_server_id: string;
            /**
             * Original Message Content
             * @description Original message content
             */
            original_message_content?: string | null;
            /**
             * Platform Message Id
             * @description Platform message ID
             */
            platform_message_id?: string | null;
            /**
             * Platform Channel Id
             * @description Platform channel ID
             */
            platform_channel_id?: string | null;
            /**
             * Platform Author Id
             * @description Platform author ID
             */
            platform_author_id?: string | null;
            /**
             * Platform Timestamp
             * @description Platform message timestamp
             */
            platform_timestamp?: string | null;
            /**
             * Metadata
             * @description Request metadata (e.g., fact-check match info)
             */
            metadata?: {
                [key: string]: unknown;
            } | null;
            /**
             * Attachment Url
             * @description URL of the first attachment (image, video, or file)
             */
            attachment_url?: string | null;
            /**
             * Attachment Type
             * @description Type of attachment
             */
            attachment_type?: ("image" | "video" | "file") | null;
            /**
             * Attachment Metadata
             * @description Attachment metadata (width, height, size, filename)
             */
            attachment_metadata?: {
                [key: string]: unknown;
            } | null;
            /**
             * Embedded Image Url
             * @description URL of embedded image (from Discord embeds or text links)
             */
            embedded_image_url?: string | null;
        };
        /**
         * RequestCreateAttributes
         * @description Attributes for creating a request via JSON:API.
         */
        RequestCreateAttributes: {
            /**
             * Request Id
             * @description Unique request identifier
             */
            request_id: string;
            /**
             * Requested By
             * @description Requester's participant ID
             */
            requested_by: string;
            /**
             * Community Server Id
             * @description Community server ID (Discord guild ID, subreddit, etc.)
             */
            community_server_id: string;
            /**
             * Original Message Content
             * @description Original message content
             */
            original_message_content?: string | null;
            /**
             * Platform Message Id
             * @description Platform message ID
             */
            platform_message_id?: string | null;
            /**
             * Platform Channel Id
             * @description Platform channel ID
             */
            platform_channel_id?: string | null;
            /**
             * Platform Author Id
             * @description Platform author ID
             */
            platform_author_id?: string | null;
            /**
             * Platform Timestamp
             * @description Platform message timestamp
             */
            platform_timestamp?: string | null;
            /**
             * Metadata
             * @description Request metadata
             */
            metadata?: {
                [key: string]: unknown;
            } | null;
        };
        /**
         * RequestCreateData
         * @description JSON:API data object for request creation.
         */
        RequestCreateData: {
            /**
             * Type
             * @description Resource type must be 'requests'
             * @constant
             */
            type: "requests";
            attributes: components["schemas"]["RequestCreateAttributes"];
        };
        /**
         * RequestCreateRequest
         * @description JSON:API request body for creating a request.
         */
        RequestCreateRequest: {
            data: components["schemas"]["RequestCreateData"];
        };
        /**
         * RequestInfo
         * @description Simplified request info for embedding in note responses
         */
        RequestInfo: {
            /** Request Id */
            request_id: string;
            /** Content */
            content?: string | null;
            /** Requested By */
            requested_by: string;
            /**
             * Requested At
             * Format: date-time
             */
            requested_at: string;
        };
        /** RequestListResponse */
        RequestListResponse: {
            /** Requests */
            requests: components["schemas"]["RequestResponse"][];
            /** Total */
            total: number;
            /** Page */
            page: number;
            /** Size */
            size: number;
        };
        /** RequestResponse */
        RequestResponse: {
            /** Created At */
            created_at: string;
            /** Updated At */
            updated_at?: string | null;
            /**
             * Request Id
             * @description Unique request identifier
             */
            request_id: string;
            /**
             * Requested By
             * @description Requester's participant ID
             */
            requested_by: string;
            /**
             * Id
             * Format: uuid
             */
            id: string;
            /**
             * Community Server Id
             * Format: uuid
             * @description Community server ID
             */
            community_server_id: string;
            /** Requested At */
            requested_at: string;
            status: components["schemas"]["RequestStatus"];
            /** Note Id */
            note_id?: string | null;
            /**
             * Content
             * @description Message content from archive or legacy field
             */
            content?: string | null;
            /**
             * Platform Message Id
             * @description Platform message ID from message archive
             */
            platform_message_id?: string | null;
            /**
             * Metadata
             * @description Request metadata (e.g., fact-check match info)
             */
            metadata?: {
                [key: string]: unknown;
            } | null;
        };
        /**
         * RequestStatus
         * @enum {string}
         */
        RequestStatus: "PENDING" | "IN_PROGRESS" | "COMPLETED" | "FAILED";
        /** RequestUpdate */
        RequestUpdate: {
            status?: components["schemas"]["RequestStatus"] | null;
            /** Note Id */
            note_id?: string | null;
        };
        /**
         * RequestUpdateAttributes
         * @description Attributes for updating a request via JSON:API.
         */
        RequestUpdateAttributes: {
            /** @description Updated request status */
            status?: components["schemas"]["RequestStatus"] | null;
            /**
             * Note Id
             * @description Associated note ID
             */
            note_id?: string | null;
        };
        /**
         * RequestUpdateData
         * @description JSON:API data object for request update.
         */
        RequestUpdateData: {
            /**
             * Type
             * @description Resource type must be 'requests'
             * @constant
             */
            type: "requests";
            /**
             * Id
             * @description Request ID being updated
             */
            id: string;
            attributes: components["schemas"]["RequestUpdateAttributes"];
        };
        /**
         * RequestUpdateRequest
         * @description JSON:API request body for updating a request.
         */
        RequestUpdateRequest: {
            data: components["schemas"]["RequestUpdateData"];
        };
        /**
         * ScoreConfidence
         * @enum {string}
         */
        ScoreConfidence: "no_data" | "provisional" | "standard";
        /** ScoringRequest */
        ScoringRequest: {
            /**
             * Notes
             * @description List of community notes to score
             */
            notes: components["schemas"]["NoteData"][];
            /**
             * Ratings
             * @description List of ratings for the notes
             */
            ratings: components["schemas"]["RatingData"][];
            /**
             * Enrollment
             * @description List of user enrollment data
             */
            enrollment: components["schemas"]["EnrollmentData"][];
            /**
             * Status
             * @description Optional note status history
             */
            status?: {
                [key: string]: unknown;
            }[] | null;
        };
        /** ScoringResponse */
        ScoringResponse: {
            /** Scored Notes */
            scored_notes: {
                [key: string]: unknown;
            }[];
            /** Helpful Scores */
            helpful_scores: {
                [key: string]: unknown;
            }[];
            /** Auxiliary Info */
            auxiliary_info: {
                [key: string]: unknown;
            }[];
        };
        /** ScoringStatusResponse */
        ScoringStatusResponse: {
            /**
             * Current Note Count
             * @description Current total number of notes in the system
             */
            current_note_count: number;
            /** @description Currently active scoring tier information */
            active_tier: components["schemas"]["TierInfo"];
            /** @description Confidence level in scoring results based on data volume */
            data_confidence: components["schemas"]["DataConfidence"];
            /**
             * Tier Thresholds
             * @description Threshold information for all tiers
             */
            tier_thresholds: {
                [key: string]: components["schemas"]["TierThreshold"];
            };
            /** @description Information about the next tier upgrade (null if at max tier) */
            next_tier_upgrade?: components["schemas"]["NextTierInfo"] | null;
            /** @description Performance metrics for the scoring system */
            performance_metrics: components["schemas"]["PerformanceMetrics"];
            /**
             * Warnings
             * @description Any warnings about data quality or scoring limitations
             */
            warnings?: string[];
            /**
             * Configuration
             * @description Current scoring configuration overrides
             */
            configuration?: {
                [key: string]: unknown;
            };
        };
        /** ServiceStatus */
        ServiceStatus: {
            /**
             * Status
             * @description Service status: 'healthy', 'degraded', or 'unhealthy'
             */
            status: string;
            /**
             * Latency Ms
             * @description Response latency in milliseconds
             */
            latency_ms?: number | null;
            /**
             * Message
             * @description Additional status message
             */
            message?: string | null;
            /**
             * Details
             * @description Additional details
             */
            details?: {
                [key: string]: unknown;
            };
        };
        /** SetConfigRequest */
        SetConfigRequest: {
            /**
             * Key
             * @description Configuration key to set (snake_case: lowercase letters, numbers, underscores, must start with letter)
             */
            key: string;
            /**
             * Value
             * @description Configuration value (stringified)
             */
            value: string;
        };
        /**
         * SimilaritySearchCreateAttributes
         * @description Attributes for performing a similarity search via JSON:API.
         */
        SimilaritySearchCreateAttributes: {
            /**
             * Text
             * @description Message text to search for similar fact-checks
             */
            text: string;
            /**
             * Community Server Id
             * @description Community server (guild) ID
             */
            community_server_id: string;
            /**
             * Dataset Tags
             * @description Dataset tags to filter by (e.g., ['snopes', 'politifact'])
             */
            dataset_tags?: string[];
            /**
             * Similarity Threshold
             * @description Minimum similarity score (0.0-1.0)
             */
            similarity_threshold?: number;
            /**
             * Limit
             * @description Maximum number of results to return
             * @default 5
             */
            limit: number;
        };
        /**
         * SimilaritySearchCreateData
         * @description JSON:API data object for similarity search.
         */
        SimilaritySearchCreateData: {
            /**
             * Type
             * @description Resource type must be 'similarity-searches'
             * @constant
             */
            type: "similarity-searches";
            attributes: components["schemas"]["SimilaritySearchCreateAttributes"];
        };
        /** SimilaritySearchResponse */
        SimilaritySearchResponse: {
            /**
             * Matches
             * @description Matching fact-check items
             */
            matches: components["schemas"]["FactCheckMatch"][];
            /**
             * Query Text
             * @description Original query text
             */
            query_text: string;
            /**
             * Dataset Tags
             * @description Dataset tags used for filtering
             */
            dataset_tags: string[];
            /**
             * Similarity Threshold
             * @description Similarity threshold applied
             */
            similarity_threshold: number;
            /**
             * Total Matches
             * @description Number of matches found
             */
            total_matches: number;
        };
        /** TaskStatus */
        TaskStatus: {
            /** Task Id */
            task_id: string;
            /** Interaction Id */
            interaction_id: string;
            /** Task Type */
            task_type: string;
            /** Status */
            status: string;
            /**
             * Result
             * @description Task result data. Kept as dict - structure varies by task type
             */
            result?: {
                [key: string]: unknown;
            } | null;
            /** Error */
            error?: string | null;
            /** Retry Count */
            retry_count: number;
            /** Created At */
            created_at: string;
            /** Started At */
            started_at?: string | null;
            /** Completed At */
            completed_at?: string | null;
        };
        /** TierInfo */
        TierInfo: {
            /**
             * Level
             * @description Numeric tier level (0-5)
             */
            level: number;
            /**
             * Name
             * @description Human-readable tier name
             */
            name: string;
            /**
             * Scorer Components
             * @description List of scorer components active in this tier
             */
            scorer_components: string[];
        };
        /** TierThreshold */
        TierThreshold: {
            /**
             * Min
             * @description Minimum note count for this tier
             */
            min: number;
            /**
             * Max
             * @description Maximum note count for this tier (null for unlimited)
             */
            max: number | null;
            /**
             * Current
             * @description Whether this is the currently active tier
             */
            current: boolean;
        };
        /** Token */
        Token: {
            /** Access Token */
            access_token: string;
            /**
             * Token Type
             * @default bearer
             */
            token_type: string;
            /** Refresh Token */
            refresh_token?: string | null;
            /** Expires In */
            expires_in: number;
        };
        /** TopNotesResponse */
        TopNotesResponse: {
            /**
             * Notes
             * @description List of top-scored notes with metadata
             */
            notes: components["schemas"]["NoteScoreResponse"][];
            /**
             * Total Count
             * @description Total number of notes matching filters (before pagination)
             */
            total_count: number;
            /**
             * Filters Applied
             * @description Filters that were applied to the query
             */
            filters_applied?: {
                [key: string]: unknown;
            };
            /**
             * Current Tier
             * @description Current scoring tier level for the system
             */
            current_tier: number;
        };
        /** UserCreate */
        UserCreate: {
            /** Username */
            username: string;
            /**
             * Email
             * Format: email
             */
            email: string;
            /** Password */
            password: string;
            /** Full Name */
            full_name?: string | null;
        };
        /**
         * UserIdentityResponse
         * @description API response schema for user identity (excludes sensitive fields).
         */
        "UserIdentityResponse-Input": {
            /**
             * Created At
             * Format: date-time
             */
            created_at: string;
            /** Updated At */
            updated_at?: string | null;
            /**
             * Id
             * Format: uuid
             * @description Unique identity identifier
             */
            id: string;
            /**
             * Profile Id
             * Format: uuid
             * @description Associated user profile ID
             */
            profile_id: string;
            /** @description Authentication provider */
            provider: components["schemas"]["AuthProvider"];
            /**
             * Provider User Id
             * @description User's unique ID on the provider
             */
            provider_user_id: string;
            /**
             * Email Verified
             * @description Whether email address is verified
             */
            email_verified: boolean;
        };
        /**
         * UserIdentityResponse
         * @description API response schema for user identity (excludes sensitive fields).
         */
        "UserIdentityResponse-Output": {
            /** Created At */
            created_at: string;
            /** Updated At */
            updated_at?: string | null;
            /**
             * Id
             * Format: uuid
             * @description Unique identity identifier
             */
            id: string;
            /**
             * Profile Id
             * Format: uuid
             * @description Associated user profile ID
             */
            profile_id: string;
            /** @description Authentication provider */
            provider: components["schemas"]["AuthProvider"];
            /**
             * Provider User Id
             * @description User's unique ID on the provider
             */
            provider_user_id: string;
            /**
             * Email Verified
             * @description Whether email address is verified
             */
            email_verified: boolean;
        };
        /**
         * UserProfileResponse
         * @description API response schema for user profile with nested relationships.
         */
        "UserProfileResponse-Input": {
            /**
             * Created At
             * Format: date-time
             */
            created_at: string;
            /** Updated At */
            updated_at?: string | null;
            /**
             * Display Name
             * @description User's display name
             */
            display_name: string;
            /**
             * Avatar Url
             * @description URL to user's avatar image
             */
            avatar_url?: string | null;
            /**
             * Bio
             * @description User biography/description
             */
            bio?: string | null;
            /**
             * Role
             * @description Platform-level role (user, moderator, admin)
             * @default user
             */
            role: string;
            /**
             * Is Opennotes Admin
             * @description OpenNotes-specific admin flag (grants cross-community admin privileges)
             * @default false
             */
            is_opennotes_admin: boolean;
            /**
             * Is Human
             * @description Distinguishes human users from bot accounts
             * @default true
             */
            is_human: boolean;
            /**
             * Is Active
             * @description Whether the profile is active
             * @default true
             */
            is_active: boolean;
            /**
             * Is Banned
             * @description Whether the profile is banned
             * @default false
             */
            is_banned: boolean;
            /**
             * Banned At
             * @description Timestamp when profile was banned
             */
            banned_at?: string | null;
            /**
             * Banned Reason
             * @description Reason for ban
             */
            banned_reason?: string | null;
            /**
             * Id
             * Format: uuid
             * @description Unique profile identifier
             */
            id: string;
            /**
             * Reputation
             * @description Global reputation score
             * @default 0
             */
            reputation: number;
            /**
             * Identities
             * @description Linked authentication identities
             */
            identities?: components["schemas"]["UserIdentityResponse-Input"][];
            /**
             * Community Memberships
             * @description Community memberships
             */
            community_memberships?: components["schemas"]["CommunityMemberResponse-Input"][];
        };
        /**
         * UserProfileResponse
         * @description API response schema for user profile with nested relationships.
         */
        "UserProfileResponse-Output": {
            /** Created At */
            created_at: string;
            /** Updated At */
            updated_at?: string | null;
            /**
             * Display Name
             * @description User's display name
             */
            display_name: string;
            /**
             * Avatar Url
             * @description URL to user's avatar image
             */
            avatar_url?: string | null;
            /**
             * Bio
             * @description User biography/description
             */
            bio?: string | null;
            /**
             * Role
             * @description Platform-level role (user, moderator, admin)
             * @default user
             */
            role: string;
            /**
             * Is Opennotes Admin
             * @description OpenNotes-specific admin flag (grants cross-community admin privileges)
             * @default false
             */
            is_opennotes_admin: boolean;
            /**
             * Is Human
             * @description Distinguishes human users from bot accounts
             * @default true
             */
            is_human: boolean;
            /**
             * Is Active
             * @description Whether the profile is active
             * @default true
             */
            is_active: boolean;
            /**
             * Is Banned
             * @description Whether the profile is banned
             * @default false
             */
            is_banned: boolean;
            /**
             * Banned At
             * @description Timestamp when profile was banned
             */
            banned_at?: string | null;
            /**
             * Banned Reason
             * @description Reason for ban
             */
            banned_reason?: string | null;
            /**
             * Id
             * Format: uuid
             * @description Unique profile identifier
             */
            id: string;
            /**
             * Reputation
             * @description Global reputation score
             * @default 0
             */
            reputation: number;
            /**
             * Identities
             * @description Linked authentication identities
             */
            identities?: components["schemas"]["UserIdentityResponse-Output"][];
            /**
             * Community Memberships
             * @description Community memberships
             */
            community_memberships?: components["schemas"]["CommunityMemberResponse-Output"][];
        };
        /**
         * UserProfileSelfUpdate
         * @description Schema for users updating their own profile (self-service).
         *
         *     Security: This schema only exposes user-editable fields.
         *     Privileged fields (role, is_opennotes_admin, is_banned, etc.) are
         *     intentionally excluded to prevent privilege escalation attacks.
         *
         *     Use UserProfileAdminUpdate for admin operations on user profiles.
         */
        UserProfileSelfUpdate: {
            /**
             * Display Name
             * @description User's display name
             */
            display_name?: string | null;
            /**
             * Avatar Url
             * @description URL to user's avatar image
             */
            avatar_url?: string | null;
            /**
             * Bio
             * @description User biography/description
             */
            bio?: string | null;
        };
        /** UserResponse */
        UserResponse: {
            /**
             * Id
             * Format: uuid
             */
            id: string;
            /** Username */
            username: string;
            /** Email */
            email: string;
            /** Full Name */
            full_name: string | null;
            /** Role */
            role: string;
            /** Is Active */
            is_active: boolean;
            /** Is Superuser */
            is_superuser: boolean;
            /**
             * Created At
             * Format: date-time
             */
            created_at: string;
            /**
             * Updated At
             * Format: date-time
             */
            updated_at: string;
        };
        /** UserUpdate */
        UserUpdate: {
            /** Email */
            email?: string | null;
            /** Full Name */
            full_name?: string | null;
            /** Password */
            password?: string | null;
        };
        /** ValidationError */
        ValidationError: {
            /** Location */
            loc: (string | number)[];
            /** Message */
            msg: string;
            /** Error Type */
            type: string;
        };
        /** WebhookConfigResponse */
        WebhookConfigResponse: {
            /**
             * Id
             * Format: uuid
             */
            id: string;
            /** Url */
            url: string;
            /** Community Server Id */
            community_server_id: string;
            /** Channel Id */
            channel_id?: string | null;
            /** Active */
            active: boolean;
        };
        /** WebhookConfigSecure */
        WebhookConfigSecure: {
            /**
             * Id
             * Format: uuid
             */
            id: string;
            /** Url */
            url: string;
            /** Community Server Id */
            community_server_id: string;
            /** Channel Id */
            channel_id?: string | null;
            /** Active */
            active: boolean;
            /** Secret */
            secret: string;
        };
        /** WebhookCreateRequest */
        WebhookCreateRequest: {
            /**
             * Url
             * @description Webhook URL
             */
            url: string;
            /**
             * Secret
             * @description Webhook secret
             */
            secret: string;
            /**
             * Community Server Id
             * @description Community server ID (Discord guild ID, subreddit name, etc.)
             */
            community_server_id: string;
            /**
             * Channel Id
             * @description Channel ID (Discord channel ID, etc.)
             */
            channel_id?: string | null;
        };
        /** WebhookUpdateRequest */
        WebhookUpdateRequest: {
            /** Url */
            url?: string | null;
            /** Secret */
            secret?: string | null;
            /** Channel Id */
            channel_id?: string | null;
            /** Active */
            active?: boolean | null;
        };
        /**
         * SimilaritySearchRequest
         * @description Request schema for similarity search against fact-check items.
         */
        src__fact_checking__embedding_schemas__SimilaritySearchRequest: {
            /**
             * Text
             * @description Message text to search for similar fact-checks
             */
            text: string;
            /**
             * Community Server Id
             * @description Community server (guild) ID
             */
            community_server_id: string;
            /**
             * Dataset Tags
             * @description Dataset tags to filter by (e.g., ['snopes', 'politifact'])
             */
            dataset_tags?: string[];
            /**
             * Similarity Threshold
             * @description Minimum similarity score (0.0-1.0)
             */
            similarity_threshold?: number;
            /**
             * Limit
             * @description Maximum number of results to return
             * @default 5
             */
            limit: number;
        };
        /**
         * SimilaritySearchRequest
         * @description JSON:API request body for performing a similarity search.
         */
        src__fact_checking__embeddings_jsonapi_router__SimilaritySearchRequest: {
            data: components["schemas"]["SimilaritySearchCreateData"];
        };
        /**
         * PreviouslySeenCheckRequest
         * @description JSON:API request body for checking previously seen messages.
         */
        src__fact_checking__previously_seen_jsonapi_router__PreviouslySeenCheckRequest: {
            data: components["schemas"]["PreviouslySeenCheckData"];
        };
        /**
         * PreviouslySeenCheckRequest
         * @description Request to check for previously seen messages.
         */
        src__fact_checking__previously_seen_router__PreviouslySeenCheckRequest: {
            /**
             * Messagetext
             * @description Message text to check
             */
            messageText: string;
            /**
             * Guildid
             * @description Discord guild ID
             */
            guildId: string;
            /**
             * Channelid
             * @description Discord channel ID
             */
            channelId: string;
        };
    };
    responses: never;
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    register_api_v1_auth_register_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["UserCreate"];
            };
        };
        responses: {
            /** @description Successful Response */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UserResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    login_api_v1_auth_login_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/x-www-form-urlencoded": components["schemas"]["Body_login_api_v1_auth_login_post"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Token"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    refresh_access_token_api_v1_auth_refresh_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RefreshTokenRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Token"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    logout_api_v1_auth_logout_post: {
        parameters: {
            query: {
                refresh_token: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    logout_all_api_v1_auth_logout_all_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    revoke_current_token_api_v1_auth_revoke_token_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    revoke_all_tokens_api_v1_auth_revoke_all_tokens_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    get_current_user_profile_api_v1_users_me_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UserResponse"];
                };
            };
        };
    };
    update_current_user_profile_api_v1_users_me_patch: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["UserUpdate"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UserResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_login_history_api_v1_users_me_login_history_get: {
        parameters: {
            query?: {
                limit?: number;
                offset?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AuditLogResponse"][];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    list_user_api_keys_api_v1_users_me_api_keys_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["APIKeyResponse"][];
                };
            };
        };
    };
    create_user_api_key_api_v1_users_me_api_keys_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["APIKeyCreate"];
            };
        };
        responses: {
            /** @description Successful Response */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["APIKeyResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    revoke_user_api_key_api_v1_users_me_api_keys__api_key_id__delete: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                api_key_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    init_discord_oauth_api_v1_profile_auth_discord_init_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DiscordOAuthInitResponse"];
                };
            };
        };
    };
    register_discord_api_v1_profile_auth_register_discord_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["DiscordOAuthRegisterRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UserProfileResponse-Output"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    register_email_api_v1_profile_auth_register_email_post: {
        parameters: {
            query: {
                email: string;
                password: string;
                display_name: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UserProfileResponse-Output"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    login_discord_api_v1_profile_auth_login_discord_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["DiscordOAuthLoginRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Token"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    login_email_api_v1_profile_auth_login_email_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/x-www-form-urlencoded": components["schemas"]["Body_login_email_api_v1_profile_auth_login_email_post"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Token"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    verify_email_api_v1_profile_auth_verify_email_post: {
        parameters: {
            query: {
                token: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UserProfileResponse-Output"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    resend_verification_email_api_v1_profile_auth_resend_verification_post: {
        parameters: {
            query: {
                email: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        [key: string]: string;
                    };
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    migrate_legacy_user_to_profile_api_v1_profile_auth_migrate_profile_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Token"];
                };
            };
        };
    };
    get_current_profile_endpoint_api_v1_profile_me_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UserProfileResponse-Output"];
                };
            };
        };
    };
    update_current_profile_endpoint_api_v1_profile_me_patch: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["UserProfileSelfUpdate"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UserProfileResponse-Output"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    revoke_profile_token_api_v1_profile_auth_revoke_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    get_opennotes_admin_status_api_v1_admin_profiles__profile_id__opennotes_admin_get: {
        parameters: {
            query?: never;
            header?: {
                "X-API-Key"?: string | null;
            };
            path: {
                profile_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        [key: string]: boolean;
                    };
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    set_opennotes_admin_status_api_v1_admin_profiles__profile_id__opennotes_admin_patch: {
        parameters: {
            query: {
                is_admin: boolean;
            };
            header?: {
                "X-API-Key"?: string | null;
            };
            path: {
                profile_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UserProfileResponse-Output"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    list_notes_jsonapi_api_v2_notes_get: {
        parameters: {
            query?: {
                "page[number]"?: number;
                "page[size]"?: number;
                "filter[status]"?: components["schemas"]["NoteStatus"] | null;
                "filter[status__neq]"?: components["schemas"]["NoteStatus"] | null;
                "filter[classification]"?: components["schemas"]["NoteClassification"] | null;
                "filter[community_server_id]"?: string | null;
                "filter[author_participant_id]"?: string | null;
                "filter[request_id]"?: string | null;
                "filter[created_at__gte]"?: string | null;
                "filter[created_at__lte]"?: string | null;
                "filter[rated_by_participant_id__not_in]"?: string | null;
            };
            header?: {
                "X-API-Key"?: string | null;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    create_note_jsonapi_api_v2_notes_post: {
        parameters: {
            query?: never;
            header?: {
                "X-API-Key"?: string | null;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["NoteCreateRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_note_jsonapi_api_v2_notes__note_id__get: {
        parameters: {
            query?: never;
            header?: {
                "X-API-Key"?: string | null;
            };
            path: {
                note_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    delete_note_jsonapi_api_v2_notes__note_id__delete: {
        parameters: {
            query?: never;
            header?: {
                "X-API-Key"?: string | null;
            };
            path: {
                note_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    update_note_jsonapi_api_v2_notes__note_id__patch: {
        parameters: {
            query?: never;
            header?: {
                "X-API-Key"?: string | null;
            };
            path: {
                note_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["NoteUpdateRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    force_publish_note_jsonapi_api_v2_notes__note_id__force_publish_post: {
        parameters: {
            query?: never;
            header?: {
                "X-API-Key"?: string | null;
            };
            path: {
                note_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    create_rating_jsonapi_api_v2_ratings_post: {
        parameters: {
            query?: never;
            header?: {
                "X-API-Key"?: string | null;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RatingCreateRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    list_note_ratings_jsonapi_api_v2_notes__note_id__ratings_get: {
        parameters: {
            query?: never;
            header?: {
                "X-API-Key"?: string | null;
            };
            path: {
                note_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    update_rating_jsonapi_api_v2_ratings__rating_id__put: {
        parameters: {
            query?: never;
            header?: {
                "X-API-Key"?: string | null;
            };
            path: {
                rating_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RatingUpdateRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_rating_stats_jsonapi_api_v2_notes__note_id__ratings_stats_get: {
        parameters: {
            query?: never;
            header?: {
                "X-API-Key"?: string | null;
            };
            path: {
                note_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_current_profile_jsonapi_api_v2_profiles_me_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
        };
    };
    update_profile_jsonapi_api_v2_profiles_me_patch: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ProfileUpdateRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    list_user_identities_jsonapi_api_v2_profiles_me_identities_get: {
        parameters: {
            query?: {
                limit?: number;
                offset?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    link_identity_jsonapi_api_v2_profiles_me_identities_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["IdentityCreateRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    unlink_identity_jsonapi_api_v2_profiles_me_identities__identity_id__delete: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                identity_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    list_user_communities_jsonapi_api_v2_profiles_me_communities_get: {
        parameters: {
            query?: {
                limit?: number;
                offset?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_public_profile_jsonapi_api_v2_profiles__profile_id__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                profile_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_admin_status_jsonapi_api_v2_profiles__profile_id__opennotes_admin_get: {
        parameters: {
            query?: never;
            header?: {
                "X-API-Key"?: string | null;
            };
            path: {
                profile_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    update_admin_status_jsonapi_api_v2_profiles__profile_id__opennotes_admin_patch: {
        parameters: {
            query?: never;
            header?: {
                "X-API-Key"?: string | null;
            };
            path: {
                profile_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["AdminStatusUpdateRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    lookup_community_server_jsonapi_api_v2_community_servers_lookup_get: {
        parameters: {
            query: {
                /** @description Platform type */
                platform?: string;
                /** @description Platform-specific ID (e.g., Discord guild ID) */
                platform_id: string;
            };
            header?: {
                "X-API-Key"?: string | null;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_community_server_jsonapi_api_v2_community_servers__server_id__get: {
        parameters: {
            query?: never;
            header?: {
                "X-API-Key"?: string | null;
            };
            path: {
                server_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_notes_stats_jsonapi_api_v2_stats_notes_get: {
        parameters: {
            query?: {
                "filter[date_from]"?: string | null;
                "filter[date_to]"?: string | null;
                "filter[community_server_id]"?: string | null;
            };
            header?: {
                "X-API-Key"?: string | null;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_participant_stats_jsonapi_api_v2_stats_participant__participant_id__get: {
        parameters: {
            query?: {
                "filter[community_server_id]"?: string | null;
            };
            header?: {
                "X-API-Key"?: string | null;
            };
            path: {
                participant_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    list_requests_jsonapi_api_v2_requests_get: {
        parameters: {
            query?: {
                "page[number]"?: number;
                "page[size]"?: number;
                "filter[status]"?: components["schemas"]["RequestStatus"] | null;
                "filter[community_server_id]"?: string | null;
                "filter[requested_by]"?: string | null;
                "filter[requested_at__gte]"?: string | null;
                "filter[requested_at__lte]"?: string | null;
            };
            header?: {
                "X-API-Key"?: string | null;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    create_request_jsonapi_api_v2_requests_post: {
        parameters: {
            query?: never;
            header?: {
                "X-API-Key"?: string | null;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RequestCreateRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_request_jsonapi_api_v2_requests__request_id__get: {
        parameters: {
            query?: never;
            header?: {
                "X-API-Key"?: string | null;
            };
            path: {
                request_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    update_request_jsonapi_api_v2_requests__request_id__patch: {
        parameters: {
            query?: never;
            header?: {
                "X-API-Key"?: string | null;
            };
            path: {
                request_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RequestUpdateRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_scoring_status_jsonapi_api_v2_scoring_status_get: {
        parameters: {
            query?: never;
            header?: {
                "X-API-Key"?: string | null;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_note_score_jsonapi_api_v2_scoring_notes__note_id__score_get: {
        parameters: {
            query?: never;
            header?: {
                "X-API-Key"?: string | null;
            };
            path: {
                note_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_batch_scores_jsonapi_api_v2_scoring_notes_batch_scores_post: {
        parameters: {
            query?: never;
            header?: {
                "X-API-Key"?: string | null;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["BatchScoreJSONAPIRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_top_notes_jsonapi_api_v2_scoring_notes_top_get: {
        parameters: {
            query?: {
                /** @description Maximum number of notes to return */
                limit?: number;
                /** @description Minimum confidence level filter */
                min_confidence?: components["schemas"]["ScoreConfidence"] | null;
                /** @description Filter by scoring tier */
                tier?: number | null;
                /** @description Batch size for processing */
                batch_size?: number;
                /** @description Filter by community server */
                community_server_id?: string | null;
            };
            header?: {
                "X-API-Key"?: string | null;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    list_monitored_channels_jsonapi_api_v2_monitored_channels_get: {
        parameters: {
            query?: {
                "page[number]"?: number;
                "page[size]"?: number;
                "filter[community_server_id]"?: string | null;
                "filter[enabled]"?: boolean | null;
            };
            header?: {
                "X-API-Key"?: string | null;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    create_monitored_channel_jsonapi_api_v2_monitored_channels_post: {
        parameters: {
            query?: never;
            header?: {
                "X-API-Key"?: string | null;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["MonitoredChannelCreateRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_monitored_channel_jsonapi_api_v2_monitored_channels__channel_uuid__get: {
        parameters: {
            query?: never;
            header?: {
                "X-API-Key"?: string | null;
            };
            path: {
                channel_uuid: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    delete_monitored_channel_jsonapi_api_v2_monitored_channels__channel_uuid__delete: {
        parameters: {
            query?: never;
            header?: {
                "X-API-Key"?: string | null;
            };
            path: {
                channel_uuid: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    update_monitored_channel_jsonapi_api_v2_monitored_channels__channel_uuid__patch: {
        parameters: {
            query?: never;
            header?: {
                "X-API-Key"?: string | null;
            };
            path: {
                channel_uuid: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["MonitoredChannelUpdateRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    list_note_publisher_configs_jsonapi_api_v2_note_publisher_configs_get: {
        parameters: {
            query?: {
                "page[number]"?: number;
                "page[size]"?: number;
                "filter[community_server_id]"?: string | null;
                "filter[enabled]"?: boolean | null;
            };
            header?: {
                "X-API-Key"?: string | null;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    create_note_publisher_config_jsonapi_api_v2_note_publisher_configs_post: {
        parameters: {
            query?: never;
            header?: {
                "X-API-Key"?: string | null;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["NotePublisherConfigCreateRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_note_publisher_config_jsonapi_api_v2_note_publisher_configs__config_uuid__get: {
        parameters: {
            query?: never;
            header?: {
                "X-API-Key"?: string | null;
            };
            path: {
                config_uuid: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    delete_note_publisher_config_jsonapi_api_v2_note_publisher_configs__config_uuid__delete: {
        parameters: {
            query?: never;
            header?: {
                "X-API-Key"?: string | null;
            };
            path: {
                config_uuid: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    update_note_publisher_config_jsonapi_api_v2_note_publisher_configs__config_uuid__patch: {
        parameters: {
            query?: never;
            header?: {
                "X-API-Key"?: string | null;
            };
            path: {
                config_uuid: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["NotePublisherConfigUpdateRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    list_note_publisher_posts_jsonapi_api_v2_note_publisher_posts_get: {
        parameters: {
            query?: {
                "page[number]"?: number;
                "page[size]"?: number;
                "filter[community_server_id]"?: string | null;
                "filter[channel_id]"?: string | null;
                "filter[success]"?: boolean | null;
            };
            header?: {
                "X-API-Key"?: string | null;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    create_note_publisher_post_jsonapi_api_v2_note_publisher_posts_post: {
        parameters: {
            query?: never;
            header?: {
                "X-API-Key"?: string | null;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["NotePublisherPostCreateRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_note_publisher_post_jsonapi_api_v2_note_publisher_posts__post_uuid__get: {
        parameters: {
            query?: never;
            header?: {
                "X-API-Key"?: string | null;
            };
            path: {
                post_uuid: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    list_previously_seen_messages_jsonapi_api_v2_previously_seen_messages_get: {
        parameters: {
            query?: {
                "page[number]"?: number;
                "page[size]"?: number;
                "filter[community_server_id]"?: string | null;
            };
            header?: {
                "X-API-Key"?: string | null;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    create_previously_seen_message_jsonapi_api_v2_previously_seen_messages_post: {
        parameters: {
            query?: never;
            header?: {
                "X-API-Key"?: string | null;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["PreviouslySeenMessageCreateRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_previously_seen_message_jsonapi_api_v2_previously_seen_messages__message_uuid__get: {
        parameters: {
            query?: never;
            header?: {
                "X-API-Key"?: string | null;
            };
            path: {
                message_uuid: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    check_previously_seen_jsonapi_api_v2_previously_seen_messages_check_post: {
        parameters: {
            query?: never;
            header?: {
                "X-API-Key"?: string | null;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["src__fact_checking__previously_seen_jsonapi_router__PreviouslySeenCheckRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    similarity_search_jsonapi_api_v2_similarity_searches_post: {
        parameters: {
            query?: never;
            header?: {
                "X-API-Key"?: string | null;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["src__fact_checking__embeddings_jsonapi_router__SimilaritySearchRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    list_notes_api_v1_notes_get: {
        parameters: {
            query?: {
                page?: number;
                size?: number;
                author_id?: string | null;
                request_id?: string | null;
                status_filter?: components["schemas"]["NoteStatus"] | null;
                classification?: components["schemas"]["NoteClassification"] | null;
                date_from?: string | null;
                date_to?: string | null;
                community_server_id?: string | null;
                rated_by_participant_id?: string | null;
                exclude_status?: components["schemas"]["NoteStatus"][] | null;
            };
            header?: {
                "X-API-Key"?: string | null;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["NoteListResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    create_note_api_v1_notes_post: {
        parameters: {
            query?: never;
            header?: {
                "X-API-Key"?: string | null;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["NoteCreate"];
            };
        };
        responses: {
            /** @description Successful Response */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["NoteResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_note_api_v1_notes__note_id__get: {
        parameters: {
            query?: never;
            header?: {
                "X-API-Key"?: string | null;
            };
            path: {
                note_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["NoteResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    delete_note_api_v1_notes__note_id__delete: {
        parameters: {
            query?: never;
            header?: {
                "X-API-Key"?: string | null;
            };
            path: {
                note_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    update_note_api_v1_notes__note_id__patch: {
        parameters: {
            query?: never;
            header?: {
                "X-API-Key"?: string | null;
            };
            path: {
                note_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["NoteUpdate"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["NoteResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    force_publish_note_api_v1_notes__note_id__force_publish_post: {
        parameters: {
            query?: never;
            header?: {
                "X-API-Key"?: string | null;
            };
            path: {
                note_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["NoteResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    list_requests_api_v1_requests_get: {
        parameters: {
            query?: {
                page?: number;
                size?: number;
                status_filter?: components["schemas"]["RequestStatus"] | null;
                requested_by?: string | null;
                date_from?: string | null;
                date_to?: string | null;
                community_server_id?: string | null;
            };
            header?: {
                "X-API-Key"?: string | null;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RequestListResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    create_request_api_v1_requests_post: {
        parameters: {
            query?: never;
            header?: {
                "X-API-Key"?: string | null;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RequestCreate"];
            };
        };
        responses: {
            /** @description Successful Response */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RequestResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_request_api_v1_requests__request_id__get: {
        parameters: {
            query?: never;
            header?: {
                "X-API-Key"?: string | null;
            };
            path: {
                request_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RequestResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    update_request_api_v1_requests__request_id__patch: {
        parameters: {
            query?: never;
            header?: {
                "X-API-Key"?: string | null;
            };
            path: {
                request_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RequestUpdate"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RequestResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    generate_ai_note_api_v1_requests__request_id__generate_ai_note_post: {
        parameters: {
            query?: never;
            header?: {
                "X-API-Key"?: string | null;
            };
            path: {
                request_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["NoteResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_notes_stats_api_v1_stats_notes_get: {
        parameters: {
            query?: {
                date_from?: string | null;
                date_to?: string | null;
                community_server_id?: string | null;
            };
            header?: {
                "X-API-Key"?: string | null;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["NoteSummaryStats"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_participant_stats_api_v1_stats_participant__participant_id__get: {
        parameters: {
            query?: {
                community_server_id?: string | null;
            };
            header?: {
                "X-API-Key"?: string | null;
            };
            path: {
                participant_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ParticipantStats"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_scoring_status_api_v1_scoring_status_get: {
        parameters: {
            query?: never;
            header?: {
                "X-API-Key"?: string | null;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ScoringStatusResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_note_score_api_v1_scoring_notes__note_id__score_get: {
        parameters: {
            query?: never;
            header?: {
                "X-API-Key"?: string | null;
            };
            path: {
                note_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["NoteScoreResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_batch_note_scores_api_v1_scoring_notes_batch_scores_post: {
        parameters: {
            query?: never;
            header?: {
                "X-API-Key"?: string | null;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["BatchScoreRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BatchScoreResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_top_notes_api_v1_scoring_notes_top_get: {
        parameters: {
            query?: {
                /** @description Maximum number of notes to return */
                limit?: number;
                /** @description Minimum confidence level filter (no_data, provisional, standard) */
                min_confidence?: components["schemas"]["ScoreConfidence"] | null;
                /** @description Filter by scoring tier (0-5) */
                tier?: number | null;
                /** @description Batch size for processing notes */
                batch_size?: number;
                /** @description Filter by community server */
                community_server_id?: string | null;
            };
            header?: {
                "X-API-Key"?: string | null;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TopNotesResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    score_notes_api_v1_scoring_score_post: {
        parameters: {
            query?: never;
            header?: {
                "X-API-Key"?: string | null;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ScoringRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ScoringResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    scoring_health_api_v1_scoring_health_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        [key: string]: string;
                    };
                };
            };
        };
    };
    get_note_publisher_config_api_v1_note_publisher_config_get: {
        parameters: {
            query: {
                community_server_id: string;
                channel_id?: string | null;
            };
            header?: {
                "X-API-Key"?: string | null;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["NotePublisherConfigResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    set_note_publisher_config_api_v1_note_publisher_config_post: {
        parameters: {
            query?: never;
            header?: {
                "X-API-Key"?: string | null;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["NotePublisherConfigRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["NotePublisherConfigResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    record_note_publisher_api_v1_note_publisher_record_post: {
        parameters: {
            query?: never;
            header?: {
                "X-API-Key"?: string | null;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["NotePublisherRecordRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        [key: string]: string;
                    };
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    check_duplicate_api_v1_note_publisher_check_duplicate__original_message_id__get: {
        parameters: {
            query?: never;
            header?: {
                "X-API-Key"?: string | null;
            };
            path: {
                original_message_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DuplicateCheckResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_last_post_api_v1_note_publisher_last_post__channel_id__get: {
        parameters: {
            query: {
                /** @description Discord guild ID for membership verification */
                community_server_id: string;
            };
            header?: {
                "X-API-Key"?: string | null;
            };
            path: {
                channel_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["LastPostResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    handle_discord_interaction_api_v1_webhooks_discord_interactions_post: {
        parameters: {
            query?: never;
            header: {
                "x-signature-ed25519": string;
                "x-signature-timestamp": string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        [key: string]: unknown;
                    };
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    register_webhook_api_v1_webhooks_register_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["WebhookCreateRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["WebhookConfigSecure"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_webhooks_by_community_server_api_v1_webhooks__community_server_id__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                community_server_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["WebhookConfigResponse"][];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    update_webhook_api_v1_webhooks__webhook_id__put: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                webhook_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["WebhookUpdateRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["WebhookConfigResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    delete_webhook_api_v1_webhooks__webhook_id__delete: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                webhook_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        [key: string]: string;
                    };
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    webhook_health_api_v1_webhooks_health_webhooks_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        [key: string]: unknown;
                    };
                };
            };
        };
    };
    get_community_server_stats_api_v1_webhooks_stats__community_server_id__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                community_server_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        [key: string]: unknown;
                    };
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_task_by_interaction_api_v1_webhooks_tasks_by_interaction__interaction_id__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                interaction_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TaskStatus"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_task_by_id_api_v1_webhooks_tasks__task_id__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                task_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TaskStatus"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_rating_thresholds_api_v1_config_rating_thresholds_get: {
        parameters: {
            query?: never;
            header?: {
                "X-API-Key"?: string | null;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RatingThresholdsResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_community_config_api_v1_community_config__community_server_id__get: {
        parameters: {
            query?: never;
            header?: {
                "X-API-Key"?: string | null;
            };
            path: {
                community_server_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CommunityConfigResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    set_community_config_api_v1_community_config__community_server_id__put: {
        parameters: {
            query?: never;
            header?: {
                "X-API-Key"?: string | null;
            };
            path: {
                community_server_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["SetConfigRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    reset_community_config_api_v1_community_config__community_server_id__delete: {
        parameters: {
            query?: {
                /** @description Specific config key to reset (leave empty to reset all) */
                config_key?: string | null;
            };
            header?: {
                "X-API-Key"?: string | null;
            };
            path: {
                community_server_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    lookup_community_server_api_v1_community_servers_lookup_get: {
        parameters: {
            query: {
                /** @description Platform type */
                platform?: string;
                /** @description Platform-specific ID (e.g., Discord guild ID) */
                platform_id: string;
            };
            header?: {
                "X-API-Key"?: string | null;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CommunityServerLookupResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    list_community_admins_api_v1_community_servers__community_server_id__admins_get: {
        parameters: {
            query?: never;
            header?: {
                "X-API-Key"?: string | null;
            };
            path: {
                community_server_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CommunityAdminResponse"][];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    add_community_admin_api_v1_community_servers__community_server_id__admins_post: {
        parameters: {
            query?: never;
            header?: {
                "X-API-Key"?: string | null;
            };
            path: {
                community_server_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["AddCommunityAdminRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CommunityAdminResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    remove_community_admin_api_v1_community_servers__community_server_id__admins__user_discord_id__delete: {
        parameters: {
            query?: never;
            header?: {
                "X-API-Key"?: string | null;
            };
            path: {
                community_server_id: string;
                user_discord_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RemoveCommunityAdminResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    list_llm_configs_api_v1_community_servers__community_server_id__llm_config_get: {
        parameters: {
            query?: never;
            header?: {
                "X-API-Key"?: string | null;
            };
            path: {
                community_server_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["LLMConfigResponse"][];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    create_llm_config_api_v1_community_servers__community_server_id__llm_config_post: {
        parameters: {
            query?: never;
            header?: {
                "X-API-Key"?: string | null;
            };
            path: {
                community_server_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["LLMConfigCreate"];
            };
        };
        responses: {
            /** @description Successful Response */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["LLMConfigResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_llm_config_api_v1_community_servers__community_server_id__llm_config__provider__get: {
        parameters: {
            query?: never;
            header?: {
                "X-API-Key"?: string | null;
            };
            path: {
                community_server_id: string;
                provider: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["LLMConfigResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    delete_llm_config_api_v1_community_servers__community_server_id__llm_config__provider__delete: {
        parameters: {
            query?: never;
            header?: {
                "X-API-Key"?: string | null;
            };
            path: {
                community_server_id: string;
                provider: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    update_llm_config_api_v1_community_servers__community_server_id__llm_config__provider__patch: {
        parameters: {
            query?: never;
            header?: {
                "X-API-Key"?: string | null;
            };
            path: {
                community_server_id: string;
                provider: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["LLMConfigUpdate"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["LLMConfigResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    test_llm_config_api_v1_community_servers__community_server_id__llm_config_test_post: {
        parameters: {
            query?: never;
            header?: {
                "X-API-Key"?: string | null;
            };
            path: {
                community_server_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["LLMConfigTestRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["LLMConfigTestResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_usage_stats_api_v1_community_servers__community_server_id__llm_config__provider__usage_get: {
        parameters: {
            query?: never;
            header?: {
                "X-API-Key"?: string | null;
            };
            path: {
                community_server_id: string;
                provider: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["LLMUsageStatsResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    list_monitored_channels_api_v1_monitored_channels_get: {
        parameters: {
            query?: {
                /** @description Filter by community server ID (platform ID, e.g., Discord guild ID). Required - user must be admin of this server. */
                community_server_id?: string | null;
                /** @description Only return enabled channels */
                enabled_only?: boolean;
                /** @description Page number */
                page?: number;
                /** @description Items per page */
                size?: number;
            };
            header?: {
                "X-API-Key"?: string | null;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MonitoredChannelListResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    create_monitored_channel_api_v1_monitored_channels_post: {
        parameters: {
            query?: never;
            header?: {
                "X-API-Key"?: string | null;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["MonitoredChannelCreate"];
            };
        };
        responses: {
            /** @description Successful Response */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MonitoredChannelResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_monitored_channel_api_v1_monitored_channels__channel_id__get: {
        parameters: {
            query?: never;
            header?: {
                "X-API-Key"?: string | null;
            };
            path: {
                channel_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MonitoredChannelResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    delete_monitored_channel_api_v1_monitored_channels__channel_id__delete: {
        parameters: {
            query?: never;
            header?: {
                "X-API-Key"?: string | null;
            };
            path: {
                channel_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    update_monitored_channel_api_v1_monitored_channels__channel_id__patch: {
        parameters: {
            query?: never;
            header?: {
                "X-API-Key"?: string | null;
            };
            path: {
                channel_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["MonitoredChannelUpdate"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MonitoredChannelResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    similarity_search_api_v1_embeddings_similarity_search_post: {
        parameters: {
            query?: never;
            header?: {
                "X-API-Key"?: string | null;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["src__fact_checking__embedding_schemas__SimilaritySearchRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SimilaritySearchResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    check_previously_seen_api_v1_previously_seen_check_post: {
        parameters: {
            query?: never;
            header?: {
                "X-API-Key"?: string | null;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["src__fact_checking__previously_seen_router__PreviouslySeenCheckRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PreviouslySeenCheckResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    health_check_health_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
        };
    };
    liveness_check_health_live_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        [key: string]: boolean;
                    };
                };
            };
        };
    };
    readiness_check_health_ready_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        [key: string]: boolean;
                    };
                };
            };
        };
    };
    distributed_health_check_health_distributed_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        [key: string]: unknown;
                    };
                };
            };
        };
    };
    instances_health_check_health_instances_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        [key: string]: unknown;
                    };
                };
            };
        };
    };
    instance_health_check_health_instances__instance_id__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                instance_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        [key: string]: unknown;
                    };
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    simple_health_check_health_simple_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HealthCheckResponse"];
                };
            };
        };
    };
    redis_health_health_redis_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ServiceStatus"];
                };
            };
        };
    };
    nats_health_health_nats_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ServiceStatus"];
                };
            };
        };
    };
    detailed_health_health_detailed_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HealthCheckResponse"];
                };
            };
        };
    };
    circuit_breakers_status_health_circuit_breakers_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        [key: string]: unknown;
                    };
                };
            };
        };
    };
    metrics_metrics_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
        };
    };
}
